{
  "jsdocs": {
    "description": "Rabbit Ear (c) Kraft",
    "name": "ear",
    "longname": "ear",
    "kind": "constant",
    "scope": "global",
    "params": []
  },
  "children": {
    "convert": {
      "children": {
        "objToFold": {
          "jsdocs": {
            "description": "Convert an OBJ mesh file into a FOLD object. The conversion\nwill create edge definitions and give them assignments and fold angles\ndepending on the dihedral angles, or boundary edges if only one face is adjacent.",
            "params": [
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a string containing the contents of an OBJ file,\nexpected to contain at least vertices and faces. All groups or object\nseparations are currently ignored, the contents are treated as one object.",
                "name": "obj"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD representation of the OBJ file."
              }
            ],
            "name": "objToFold",
            "longname": "objToFold",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "opxToFold": {
          "jsdocs": {
            "description": "Convert an ORIPA file (string) into an SVG (string).",
            "params": [
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "an oripa file as a string",
                "name": "oripa"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "an SVG rendering of the ORIPA file"
              }
            ],
            "name": "opxToFOLD",
            "longname": "opxToFOLD",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        }
      },
      "type": "Object"
    },
    "text": {
      "jsdocs": {
        "description": "A multi-lingual raw-text reference containing a rudimentary\nset of origami operations, the aim being to parameterize origami instructions\nallowing us to be able to easily convert from one language to another.",
        "name": "text",
        "longname": "text",
        "kind": "member",
        "scope": "global",
        "params": []
      },
      "children": {
        "axioms": {
          "children": {
            "ar": {
              "type": "Array"
            },
            "de": {
              "type": "Array"
            },
            "en": {
              "type": "Array"
            },
            "es": {
              "type": "Array"
            },
            "fr": {
              "type": "Array"
            },
            "hi": {
              "type": "Array"
            },
            "jp": {
              "type": "Array"
            },
            "ko": {
              "type": "Array"
            },
            "ms": {
              "type": "Array"
            },
            "pt": {
              "type": "Array"
            },
            "ru": {
              "type": "Array"
            },
            "tr": {
              "type": "Array"
            },
            "vi": {
              "type": "Array"
            },
            "zh": {
              "type": "Array"
            }
          },
          "type": "Object"
        },
        "instructions": {
          "children": {
            "blintz": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "closed sink": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "double rabbit ear": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "flip over": {
              "children": {
                "es": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "fold": {
              "children": {
                "es": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "inside reverse fold": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "mountain fold": {
              "children": {
                "es": {
                  "type": "String"
                },
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "open sink": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "outside reverse fold": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "petal fold": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "rabbit ear": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "sink": {
              "type": "Object"
            },
            "squash": {
              "children": {
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            },
            "valley fold": {
              "children": {
                "es": {
                  "type": "String"
                },
                "zh": {
                  "type": "String"
                }
              },
              "type": "Object"
            }
          },
          "type": "Object"
        }
      },
      "type": "Object"
    },
    "axiom": {
      "jsdocs": {
        "description": "Perform one of the seven origami axioms. Supply an optional boundary\nso that only the results possible inside the boundary will be returned.",
        "params": [
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the axiom number, 1-7. **note, 0 is not an option**",
            "name": "number"
          },
          {
            "type": {
              "names": [
                "AxiomParams"
              ]
            },
            "description": "the origami axiom parameters, lines and points,\nwhere the lines are either {RayLine} or {UniqueLine}.",
            "name": "params"
          },
          {
            "type": {
              "names": [
                "number[][]"
              ]
            },
            "optional": true,
            "description": "the optional boundary,\nincluding this will exclude results that lie outside.",
            "name": "boundary"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "RayLine[]"
              ]
            },
            "description": "an array of solutions as lines, or an empty array if no solutions."
          }
        ],
        "name": "axiom",
        "longname": "axiom",
        "kind": "function",
        "scope": "global"
      },
      "children": {
        "axiom1": {
          "jsdocs": {
            "description": "origami axiom 1: form a line that passes between the given points",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "the line in {vector, origin} form"
              }
            ],
            "name": "axiom1",
            "longname": "axiom1",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiom2": {
          "jsdocs": {
            "description": "origami axiom 2: form a perpendicular bisector between the given points",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "the line in {vector, origin} form"
              }
            ],
            "name": "axiom2",
            "longname": "axiom2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiom3": {
          "jsdocs": {
            "description": "origami axiom 3: form two lines that make the two angular bisectors between\ntwo input lines, and in the case of parallel inputs only one solution will be given",
            "params": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line1"
              },
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine[]"
                  ]
                },
                "description": "an array of lines in {vector, origin} form"
              }
            ],
            "name": "axiom3",
            "longname": "axiom3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiom4": {
          "jsdocs": {
            "description": "origami axiom 4: form a line perpendicular to a given line that\npasses through a point.",
            "params": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "the line in {vector, origin} form"
              }
            ],
            "name": "axiom4",
            "longname": "axiom4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiom5": {
          "jsdocs": {
            "description": "origami axiom 5: form up to two lines that pass through a point that also\nbrings another point onto a given line",
            "params": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point, the point that the line(s) pass through",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point, the point that is being brought onto the line",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine[]"
                  ]
                },
                "description": "an array of lines in {vector, origin} form"
              }
            ],
            "name": "axiom5",
            "longname": "axiom5",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiom6": {
          "jsdocs": {
            "description": "origami axiom 6: form up to three lines that are made by bringing\na point to a line and a second point to a second line.",
            "params": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line1"
              },
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line2"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to bring to the first line",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to bring to the second line",
                "name": "point2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine[]"
                  ]
                },
                "description": "an array of lines in {vector, origin} form"
              }
            ],
            "name": "axiom6",
            "longname": "axiom6",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiom7": {
          "jsdocs": {
            "description": "origami axiom 7: form a line by bringing a point onto a given line\nwhile being perpendicular to another given line.",
            "params": [
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form,\nthe line the point will be brought onto.",
                "name": "line1"
              },
              {
                "type": {
                  "names": [
                    "RayLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form,\nthe line which the perpendicular will be based off.",
                "name": "line2"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to bring onto the line",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine",
                    "undefined"
                  ]
                },
                "description": "the line in {vector, origin} form\nor undefined if the given lines are parallel"
              }
            ],
            "name": "axiom7",
            "longname": "axiom7",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "axiomInBoundary": {
          "jsdocs": {
            "description": "Perform one of the seven origami axioms, and provide a boundary so that\nonly the results possible inside the boundary will be returned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the axiom number, 1-7. **note, 0 is not an option**",
                "name": "number"
              },
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the origami axiom parameters, lines and points,\nwhere the lines are only {RayLine} lines.",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "optional": true,
                "description": "the optional boundary,\nincluding this will exclude results that lie outside.",
                "name": "boundary"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "RayLine[]"
                  ]
                },
                "description": "an array of solutions as lines, or an empty array if no solutions."
              }
            ],
            "name": "axiomInBoundary",
            "longname": "axiomInBoundary",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom1": {
          "jsdocs": {
            "description": "origami axiom 1: form a line that passes between the given points",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "the line in {normal, distance} form"
              }
            ],
            "name": "normalAxiom1",
            "longname": "normalAxiom1",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom2": {
          "jsdocs": {
            "description": "origami axiom 2: form a perpendicular bisector between the given points",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "the line in {normal, distance} form"
              }
            ],
            "name": "normalAxiom2",
            "longname": "normalAxiom2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom3": {
          "jsdocs": {
            "description": "origami axiom 3: form two lines that make the two angular bisectors between\ntwo input lines, and in the case of parallel inputs only one solution will be given",
            "params": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line1"
              },
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {vector, origin} form",
                "name": "line2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine[]"
                  ]
                },
                "description": "an array of lines in {normal, distance} form"
              }
            ],
            "name": "normalAxiom3",
            "longname": "normalAxiom3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom4": {
          "jsdocs": {
            "description": "origami axiom 4: form a line perpendicular to a given line that\npasses through a point.",
            "params": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {normal, distance} form",
                "name": "line"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "the line in {normal, distance} form"
              }
            ],
            "name": "normalAxiom4",
            "longname": "normalAxiom4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom5": {
          "jsdocs": {
            "description": "origami axiom 5: form up to two lines that pass through a point that also\nbrings another point onto a given line",
            "params": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {normal, distance} form",
                "name": "line"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point, the point that the line(s) pass through",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point, the point that is being brought onto the line",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine[]"
                  ]
                },
                "description": "an array of lines in {normal, distance} form"
              }
            ],
            "name": "normalAxiom5",
            "longname": "normalAxiom5",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom6": {
          "jsdocs": {
            "description": "origami axiom 6: form up to three lines that are made by bringing\na point to a line and a second point to a second line.",
            "params": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {normal, distance} form",
                "name": "line1"
              },
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {normal, distance} form",
                "name": "line2"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to bring to the first line",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to bring to the second line",
                "name": "point2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine[]"
                  ]
                },
                "description": "an array of lines in {normal, distance} form"
              }
            ],
            "name": "normalAxiom6",
            "longname": "normalAxiom6",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiom7": {
          "jsdocs": {
            "description": "origami axiom 7: form a line by bringing a point onto a given line\nwhile being perpendicular to another given line.",
            "params": [
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {normal, distance} form,\nthe line the point will be brought onto.",
                "name": "line1"
              },
              {
                "type": {
                  "names": [
                    "UniqueLine"
                  ]
                },
                "description": "one 2D line in {normal, distance} form,\nthe line which the perpendicular will be based off.",
                "name": "line2"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to bring onto the line",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine",
                    "undefined"
                  ]
                },
                "description": "the line in {normal, distance} form\nor undefined if the given lines are parallel"
              }
            ],
            "name": "normalAxiom7",
            "longname": "normalAxiom7",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalAxiomInBoundary": {
          "jsdocs": {
            "description": "Perform one of the seven origami axioms, and provide a boundary so that\nonly the results possible inside the boundary will be returned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the axiom number, 1-7. **note, 0 is not an option**",
                "name": "number"
              },
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the origami axiom parameters, lines and points,\nwhere the lines are only {UniqueLine} lines.",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "optional": true,
                "description": "the optional boundary,\nincluding this will exclude results that lie outside.",
                "name": "boundary"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "UniqueLine[]"
                  ]
                },
                "description": "an array of solutions as lines, or an empty array if no solutions."
              }
            ],
            "name": "normalAxiomInBoundary",
            "longname": "normalAxiomInBoundary",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validate": {
          "jsdocs": {
            "description": "Validate an axiom, this will run one of the submethods (\"validateAxiom1\", ...).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the axiom number, 1-7",
                "name": "number"
              },
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              },
              {
                "type": {
                  "names": [
                    "line[]"
                  ]
                },
                "description": "the solutions from the axiom method (before validation)",
                "name": "solutions"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean",
                    "boolean[]"
                  ]
                },
                "description": "for every solution, true if valid. Axioms 1, 2, 4, 7\nreturn one boolean, 3, 5, 6 return arrays of booleans."
              }
            ],
            "name": "validate",
            "longname": "validate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom1": {
          "jsdocs": {
            "description": "To validate axiom 1 check if the input points are inside the\nboundary polygon, if so, the solution is valid.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the solution is valid"
              }
            ],
            "name": "validateAxiom1",
            "longname": "validateAxiom1",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom2": {
          "jsdocs": {
            "description": "To validate axiom 2 check if the input points are inside the\nboundary polygon, if so, the solution is valid.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the solution is valid"
              }
            ],
            "name": "validateAxiom2",
            "longname": "validateAxiom2",
            "kind": "constant",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom3": {
          "jsdocs": {
            "description": "Validate axiom 3.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              },
              {
                "type": {
                  "names": [
                    "line[]"
                  ]
                },
                "description": "the solutions from the axiom method (before validation)",
                "name": "solutions"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "array of booleans (true if valid) matching the solutions array"
              }
            ],
            "name": "validateAxiom3",
            "longname": "validateAxiom3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom4": {
          "jsdocs": {
            "description": "To validate axiom 4 check if the input point lies within\nthe boundary and the intersection between the solution line and the\ninput line lies within the boundary.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the solution is valid"
              }
            ],
            "name": "validateAxiom4",
            "longname": "validateAxiom4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom5": {
          "jsdocs": {
            "description": "Validate axiom 5.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              },
              {
                "type": {
                  "names": [
                    "line[]"
                  ]
                },
                "description": "the solutions from the axiom method (before validation)",
                "name": "solutions"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "array of booleans (true if valid) matching the solutions array"
              }
            ],
            "name": "validateAxiom5",
            "longname": "validateAxiom5",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom6": {
          "jsdocs": {
            "description": "Validate axiom 6.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              },
              {
                "type": {
                  "names": [
                    "line[]"
                  ]
                },
                "description": "the solutions from the axiom method (before validation)",
                "name": "solutions"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "array of booleans (true if valid) matching the solutions array"
              }
            ],
            "name": "validateAxiom6",
            "longname": "validateAxiom6",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateAxiom7": {
          "jsdocs": {
            "description": "Validate axiom 7.",
            "params": [
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the solution is valid"
              }
            ],
            "name": "validateAxiom7",
            "longname": "validateAxiom7",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        }
      },
      "type": "Function"
    },
    "circle": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a circle defined by a radius and a center. This comes with\nobject methods and can be used in intersection calculations.",
        "params": [
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the circle's radius",
            "name": "radius"
          },
          {
            "type": {
              "names": [
                "number[]",
                "number"
              ]
            },
            "description": "the center of the circle",
            "name": "origin"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "circle"
              ]
            },
            "description": "one circle object"
          }
        ],
        "name": "circle",
        "longname": "ear.circle",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "cp": {
      "children": {
        "kite": {
          "jsdocs": {
            "description": "Create a kite base FOLD object, in crease pattern form.",
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "kite",
            "longname": "Create.kite",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "polygon": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a polygon defined by a sequence of points. This comes with\nobject methods and can be used in intersection calculations. The polygon can be non-convex,\nbut some methods only work on convex polygons.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "...Array.<number>"
                  ]
                },
                "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "polygon"
                  ]
                },
                "description": "one polygon object"
              }
            ],
            "name": "polygon",
            "longname": "ear.polygon",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "rectangle": {
          "jsdocs": {
            "description": "Create a new FOLD object which contains one rectangular face,\nincluding vertices and boundary edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the width of the rectangle",
                "name": "width"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the height of the rectangle",
                "name": "height"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "rectangle",
            "longname": "Create.rectangle",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "square": {
          "jsdocs": {
            "description": "Create a new FOLD object which contains one square face,\nincluding vertices and boundary edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the length of the sides.",
                "name": "scale"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "square",
            "longname": "Create.square",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        }
      },
      "type": "Function"
    },
    "diagram": {
      "jsdocs": {
        "description": "A collection of methods for drawing origami diagrams.",
        "name": "diagram",
        "longname": "diagram",
        "kind": "member",
        "scope": "global",
        "params": []
      },
      "children": {
        "axiom_arrows": {
          "type": "Function"
        },
        "simple_arrow": {
          "type": "Function"
        }
      },
      "type": "undefined"
    },
    "ellipse": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make an ellipse defined by a two radii and a center. This comes with object methods.",
        "params": [
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the radius along the x axis",
            "name": "rx"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the radius along the y axis",
            "name": "ry"
          },
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the center of the ellipse",
            "name": "origin"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the angle of rotation in radians",
            "name": "spin"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "ellipse"
              ]
            },
            "description": "one ellipse object"
          }
        ],
        "name": "ellipse",
        "longname": "ear.ellipse",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "graph": {
      "jsdocs": {
        "name": "Graph",
        "description": "a graph which includes faces, edges, and vertices, and additional\norigami-specific information like fold angles of edges and layer order of faces.",
        "params": [
          {
            "type": {
              "names": [
                "FOLD"
              ]
            },
            "optional": true,
            "description": "an optional FOLD object, otherwise the graph will initialize empty",
            "name": "graph"
          }
        ],
        "longname": "Graph",
        "kind": "member",
        "scope": "global"
      },
      "children": {
        "edgesAssignmentDegrees": {
          "jsdocs": {
            "description": "get the foldAngle in degrees for every FOLD assignment spec\ncharacter (like \"M\", or \"b\"). **this assumes the creases are flat folded.**",
            "name": "edgesAssignmentDegrees",
            "longname": "edgesAssignmentDegrees",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "children": {
            "b": {
              "type": "Number"
            },
            "B": {
              "type": "Number"
            },
            "f": {
              "type": "Number"
            },
            "F": {
              "type": "Number"
            },
            "m": {
              "type": "Number"
            },
            "M": {
              "type": "Number"
            },
            "u": {
              "type": "Number"
            },
            "U": {
              "type": "Number"
            },
            "v": {
              "type": "Number"
            },
            "V": {
              "type": "Number"
            }
          },
          "type": "Object"
        },
        "edgesAssignmentNames": {
          "jsdocs": {
            "description": "get the English word for every FOLD spec assignment character (like \"M\", or \"b\")",
            "name": "edgesAssignmentNames",
            "longname": "edgesAssignmentNames",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "children": {
            "b": {
              "type": "String"
            },
            "B": {
              "type": "String"
            },
            "f": {
              "type": "String"
            },
            "F": {
              "type": "String"
            },
            "m": {
              "type": "String"
            },
            "M": {
              "type": "String"
            },
            "u": {
              "type": "String"
            },
            "U": {
              "type": "String"
            },
            "v": {
              "type": "String"
            },
            "V": {
              "type": "String"
            }
          },
          "type": "Object"
        },
        "foldFileClasses": {
          "type": "Array"
        },
        "foldFrameAttributes": {
          "type": "Array"
        },
        "foldFrameClasses": {
          "type": "Array"
        },
        "foldKeys": {
          "jsdocs": {
            "description": "top-level keys in a FOLD object, sorted into usage categories.",
            "name": "foldKeys",
            "longname": "foldKeys",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Array"
        },
        "pluralize": {
          "jsdocs": {
            "description": "English conversion of the names of graph components from singular to plural.",
            "name": "pluralize",
            "longname": "pluralize",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "children": {
            "edge": {
              "type": "String"
            },
            "face": {
              "type": "String"
            },
            "vertex": {
              "type": "String"
            }
          },
          "type": "Object"
        },
        "singularize": {
          "jsdocs": {
            "description": "English conversion of the names of graph components from plural to singular.",
            "name": "singularize",
            "longname": "singularize",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "children": {
            "edges": {
              "type": "String"
            },
            "faces": {
              "type": "String"
            },
            "vertices": {
              "type": "String"
            }
          },
          "type": "Object"
        },
        "addEdges": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "addEdges",
            "longname": "addEdges",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "addPlanarSegment": {
          "jsdocs": {
            "description": "Add a segment to a planar graph and maintain planarity.\nIf endpoints lie within an epsilon to existing vertices, they will be used.\nIf edges are crossed by the new edge, these edges will be segmented and\nnew vertices will be added. Finally, all intersected faces will be rebuilt.\nIf the graph contains the arrays edges_assignment or edges_foldAngle,\nthe corresponding new edge indices will be appended with \"U\" and 0.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a planar FOLD graph, modified in place.",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 2D point as an array of numbers",
                "name": "point1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 2D point as an array of numbers",
                "name": "point2"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "optional epsilon for merging vertices",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the indices of the new edge(s) composing the segment."
              }
            ],
            "name": "addPlanarSegment",
            "longname": "addPlanarSegment",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "addVertices": {
          "jsdocs": {
            "description": "add vertices to a graph by adding their vertices_coords only. This\nwill also compare against every existing vertex, only adding non-duplicate\nvertices, as determined by an epsilon.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, modified in place.",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points to be added to the graph",
                "name": "vertices_coords"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "optional epsilon to merge similar vertices",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "index of vertex in new vertices_coords array.\nthe size of this array matches array size of source vertices.\nduplicate (non-added) vertices returns their pre-existing counterpart's index."
              }
            ],
            "name": "addVertices",
            "longname": "addVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "booleanMatrixToIndexedArray": {
          "jsdocs": {
            "description": "Convert a sparse or dense matrix containing true/false/undefined\ninto arrays containing the indices `[i,j]` of all true values.",
            "params": [
              {
                "type": {
                  "names": [
                    "(boolean|undefined)[][]"
                  ]
                },
                "description": "a 2D matrix containing boolean or undefined",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of arrays of numbers"
              }
            ],
            "name": "booleanMatrixToIndexedArray",
            "longname": "booleanMatrixToIndexedArray",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "booleanMatrixToUniqueIndexPairs": {
          "jsdocs": {
            "description": "consult the upper right half triangle of the matrix,\nfind all truthy values, gather the row/column index pairs,\nreturn them as pairs of indices in a single array.\nTriangle number, only visit half the indices. make unique pairs",
            "params": [
              {
                "type": {
                  "names": [
                    "any[][]"
                  ]
                },
                "description": "a matrix containing any type",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of pairs of numbers, the pairs of indices\nwhich are truthy in the matrix."
              }
            ],
            "name": "booleanMatrixToUniqueIndexPairs",
            "longname": "booleanMatrixToUniqueIndexPairs",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clean": {
          "jsdocs": {
            "description": "clean will remove bad graph data. this includes:\n- duplicate (Euclidean distance) and isolated vertices\n- circular and duplicate edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "summary of changes, a nextmap and the indices removed."
              }
            ],
            "name": "clean",
            "longname": "clean",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clip": {
          "jsdocs": {
            "description": "Clip a line inside the boundaries of a graph, resulting in one segment\nor undefined. The line can be a line, ray, or segment.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "RayLine",
                    "number[][]"
                  ]
                },
                "description": "a line or a segment",
                "name": "line"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "undefined"
                  ]
                },
                "description": "a segment, a pair of two points,\nor undefined if no intersection"
              }
            ],
            "name": "clip",
            "longname": "clip",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clone": {
          "jsdocs": {
            "description": "deep copy an object, like JSON.parse(JSON.stringify())\n\nthis clone function is decent, except for:\n - it doesn't detect recursive cycles\n - weird behavior around Proxys",
            "author": [
              "https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5"
            ],
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "name": "o"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a deep copy of the input"
              }
            ],
            "name": "clone",
            "longname": "clone",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clusterArrayValues": {
          "jsdocs": {
            "description": "Given an array of floats, make a sorted copy of the array,\nthen walk through the array and group similar values into clusters.\nCluster epsilon is relative to the neighbor not the entire group,\nso 1, 2, 3, 4, 5 will all be clustered together if the epsilon is 1.5.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of numbers",
                "name": "floats"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of indices to the input array."
              }
            ],
            "name": "clusterArrayValues",
            "longname": "clusterArrayValues",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "connectedComponentsArray": {
          "jsdocs": {
            "description": "given a self-relational array of arrays, for example,\nvertices_vertices, edges_edges, faces_faces, where the values in the\ninner arrays relate to the indices of the outer array, create collection groups\nwhere each item is included in a group if it points to another member\nin that group.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of arrays of numbers",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "groups of the indices where each index appears only once"
              }
            ],
            "name": "connectedComponentsArray",
            "longname": "connectedComponentsArray",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "count": {
          "jsdocs": {
            "description": "Get the number of vertices, edges, or faces in the graph by\nsimply checking the length of arrays starting with the key; in the case\nof differing array lengths (which shouldn't happen) return the largest number.\n\nThis works even with custom component names in place of \"vertices\", \"edges\"...\n\nThis will fail in the case of abstract graphs, for example where no vertices\nare defined in a vertex_ array, but still exist as mentions in faces_vertices.\nIn that case, use the implied count method. \"count_implied.js\"",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "the prefix for a key, eg: \"vertices\"",
                "name": "key"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of the requested element type in the graph"
              }
            ],
            "name": "count",
            "longname": "count",
            "kind": "function",
            "scope": "global"
          },
          "children": {
            "edges": {
              "jsdocs": {
                "description": "Get the number of edges in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of edges in the graph"
                  }
                ],
                "name": "edges",
                "longname": "count.edges",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "faces": {
              "jsdocs": {
                "description": "Get the number of faces in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of faces in the graph"
                  }
                ],
                "name": "faces",
                "longname": "count.faces",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "vertices": {
              "jsdocs": {
                "description": "Get the number of vertices in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of vertices in the graph"
                  }
                ],
                "name": "vertices",
                "longname": "count.vertices",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            }
          },
          "type": "Function"
        },
        "counterClockwiseWalk": {
          "jsdocs": {
            "description": "discover a face by walking neighboring vertices until returning to the start.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "starting vertex",
                "name": "v0"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "second vertex, this sets the direction of the walk",
                "name": "v1"
              },
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "optional": true,
                "defaultvalue": "{}",
                "description": "memo object, to prevent walking down\nduplicate paths, or finding duplicate faces, this dictionary will\nstore and check against vertex pairs \"i j\".",
                "name": "walked_edges"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "the walked face, an object arrays of numbers\nunder \"vertices\", \"edges\", and \"angles\""
              }
            ],
            "name": "counterClockwiseWalk",
            "longname": "counterClockwiseWalk",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "countImplied": {
          "jsdocs": {
            "description": "Get the number of vertices, edges, or faces in the graph, as\nevidenced by their appearance in other arrays; ie: searching faces_vertices\nfor the largest vertex index, and inferring number of vertices is that long.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "the prefix for a key, eg: \"vertices\"",
                "name": "key"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of vertices, edges, or faces in the graph."
              }
            ],
            "name": "countImplied",
            "longname": "countImplied",
            "kind": "function",
            "scope": "global"
          },
          "children": {
            "edges": {
              "jsdocs": {
                "description": "Get the number of edges in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of edges in the graph"
                  }
                ],
                "name": "edges",
                "longname": "count.edges",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "faces": {
              "jsdocs": {
                "description": "Get the number of faces in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of faces in the graph"
                  }
                ],
                "name": "faces",
                "longname": "count.faces",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "vertices": {
              "jsdocs": {
                "description": "Get the number of vertices in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of vertices in the graph"
                  }
                ],
                "name": "vertices",
                "longname": "count.vertices",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            }
          },
          "type": "Function"
        },
        "edgeAssignmentToFoldAngle": {
          "jsdocs": {
            "description": "Convert an assignment character to a foldAngle in degrees. This assumes\nthat all assignments are flat folds.",
            "params": [
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "one edge assignment letter: M V B F U",
                "name": "assignment"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "fold angle in degrees. M/V are assumed to be flat-folded."
              }
            ],
            "name": "edgeAssignmentToFoldAngle",
            "longname": "edgeAssignmentToFoldAngle",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "edgeFoldAngleIsFlat": {
          "jsdocs": {
            "description": "Test if a fold angle is a flat fold, which includes -180, 0, 180,\nand the +/- epsilon around each number.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "fold angle in degrees",
                "name": "angle"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the fold angle is flat"
              }
            ],
            "name": "edgeFoldAngleIsFlat",
            "longname": "edgeFoldAngleIsFlat",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "edgeFoldAngleToAssignment": {
          "jsdocs": {
            "description": "Convert a foldAngle to an edge assignment character.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "fold angle in degrees",
                "name": "angle"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "one edge assignment letter: M V or U, no boundary detection"
              }
            ],
            "todo": [
              "should \"U\" be \"F\" instead, if so, we are assigning potental \"B\" edges to \"F\"."
            ],
            "name": "edgeFoldAngleToAssignment",
            "longname": "edgeFoldAngleToAssignment",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "edgesFoldAngleAreAllFlat": {
          "jsdocs": {
            "description": "Provide a FOLD graph and determine if all edges_foldAngle\nangles are flat, which includes -180, 0, 180, and the +/- epsilon\naround each number. If a graph contains no \"edges_foldAngle\",\nthe angles are considered flat, and the method returns \"true\".",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "is the graph flat-foldable according to foldAngles."
              }
            ],
            "name": "edgesFoldAngleAreAllFlat",
            "longname": "edgesFoldAngleAreAllFlat",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "explode": {
          "jsdocs": {
            "description": "Create a modified graph which separates all faces from each other.\nThis will add new vertices and new edges. Most adjacency arrays will be\ndeleted as a lot of it becomes trivial. However, edges_assignment and foldAngle\nwill remain and be correctly updated to match the new edge indices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, will be modified in place",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a summary of changes to the vertices and edges"
              }
            ],
            "name": "explode",
            "longname": "explode",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "explodeFaces": {
          "jsdocs": {
            "description": "Create a modified graph which contains vertices_coords and faces_vertices\nbut that for every face, vertices_coords has been duplicated so that faces\ndo not share vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a new FOLD graph with exploded faces"
              }
            ],
            "name": "explodeFaces",
            "longname": "explodeFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "explodeShrinkFaces": {
          "jsdocs": {
            "description": "Create a modified graph which contains vertices_coords and faces_vertices\nbut that for every face, vertices_coords has been duplicated so that faces\ndo not share vertices, and finally, a scaling transform has been applied to every\nface creating a gap between all faces.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0.333,
                "description": "a scale factor for a shrinking transform",
                "name": "shrink"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a new FOLD graph with exploded faces"
              }
            ],
            "name": "explodeShrinkFaces",
            "longname": "explodeShrinkFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "faceContainingPoint": {
          "jsdocs": {
            "description": "Iterate through all faces in a graph and find one that encloses a point.\nThis method assumes the graph is in 2D, it ignores any z components.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to find the enclosing face",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number",
                    "undefined"
                  ]
                },
                "description": "the index of the face, or undefined if no face encloses a point"
              }
            ],
            "name": "faceContainingPoint",
            "longname": "faceContainingPoint",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "filterKeysWithPrefix": {
          "jsdocs": {
            "description": "Get all keys in an object that start with the provided prefix.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "an object",
                "name": "obj"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a prefix to match against the keys",
                "name": "prefix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of keys that start with the prefix"
              }
            ],
            "name": "filterKeysWithPrefix",
            "longname": "filterKeysWithPrefix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "filterKeysWithSuffix": {
          "jsdocs": {
            "description": "Get all keys in an object that end with the provided suffix.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "an object",
                "name": "obj"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a suffix to match against the keys",
                "name": "suffix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of keys that end with the suffix"
              }
            ],
            "name": "filterKeysWithSuffix",
            "longname": "filterKeysWithSuffix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "filterWalkedBoundaryFace": {
          "jsdocs": {
            "description": "This should be used in conjuction with planarVertexWalk() and\ncounterClockwiseWalk(). There will be one face in the which winds around the\noutside of the boundary and encloses the space outside around. This method will\nfind that face and remove it from the set.",
            "params": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "the result from calling \"planarVertexWalk()\"",
                "name": "walked_faces"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "the same input array with one fewer element"
              }
            ],
            "name": "filterWalkedBoundaryFace",
            "longname": "filterWalkedBoundaryFace",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "flatFold": {
          "jsdocs": {
            "description": "make a crease that passes through the entire origami and modify the\nfaces order to simulate one side of the faces flipped over and set on top.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD graph in crease pattern form, will be modified in place",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 2D vector describing the line as an array of numbers",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 2D origin describing the line as an array of numbers",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "(M/V/F) a FOLD spec encoding of the direction of the fold",
                "name": "assignment",
                "defaultvalue": "V"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a summary of changes to faces/edges."
              }
            ],
            "name": "flatFold",
            "longname": "flatFold",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "flattenFrame": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "flattenFrame",
            "longname": "flattenFrame",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "fragment": {
          "jsdocs": {
            "description": "Planarize a graph into the 2D XY plane, split edges, rebuild faces.\nThe graph provided as a method argument will be modified in place.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a summary of changes to the graph"
              }
            ],
            "name": "fragment",
            "longname": "fragment",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getBoundary": {
          "jsdocs": {
            "description": "Get the boundary of a FOLD graph in terms of both vertices and edges.\nThis works by walking the boundary edges as defined by edges_assignment (\"B\" or \"b\").\nIf edges_assignment doesn't exist, or contains errors, this will not work, and you\nwill need the more robust algorithm getPlanarBoundary() which walks the graph, but\nonly works in 2D.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "with \"vertices\" and \"edges\" with arrays of indices."
              }
            ],
            "name": "getBoundary",
            "longname": "getBoundary",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getBoundaryVertices": {
          "jsdocs": {
            "description": "For every vertex return a true if the vertex lies along a boundary\nedge, as defined by edges_assignment. If edges_assignment is not present,\nor does not contain boundary edges, this will return an empty array.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "unsorted list of vertex indices which lie along the boundary."
              }
            ],
            "name": "getBoundaryVertices",
            "longname": "getBoundaryVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getBoundingBox": {
          "jsdocs": {
            "description": "Make an axis-aligned bounding box that encloses the vertices of\na FOLD object. the optional padding is used to make the bounding box\ninclusive / exclusive by adding padding on all sides, or inset in the case\nof negative number. (positive=inclusive boundary, negative=exclusive boundary)",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "nullable": true,
                "description": "an optional padding around the vertices\nto be included in the bounding box.",
                "name": "padding"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "BoundingBox"
                  ]
                },
                "nullable": true,
                "description": "dimensions stored as \"span\" \"min\" and \"max\".\n\"undefined\" if no vertices exist in the graph."
              }
            ],
            "name": "getBoundingBox",
            "longname": "getBoundingBox",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getCircularEdges": {
          "jsdocs": {
            "description": "Get the indices of all circular edges. Circular edges are\nedges where both of its edges_vertices is the same vertex.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of indices of circular edges. empty if none."
              }
            ],
            "name": "getCircularEdges",
            "longname": "getCircularEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getCoplanarFacesGroups": {
          "jsdocs": {
            "description": "Cluster the faces of a graph into groups of face indices where\nall faces in the same group lie in the same plane in 3D (but are not\nrequired to overlap).",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of cluster objects where each cluster contains:\na normal vector, a list of face indices, and a matching list indicating\nif the face shares the normal vector or the face is flipped 180 degrees."
              }
            ],
            "name": "getCoplanarFacesGroups",
            "longname": "getCoplanarFacesGroups",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getDisjointedVertices": {
          "jsdocs": {
            "description": "Given a list of indices, and a list of pairwise combinations of\nthese indices, these pairs represent edges, separate the set of indices into\ndisjointed graphs. By providing \"indices\", this allows for isolated vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "edges of the graph encoded as as pairs of vertex indices.",
                "name": "edges"
              }
            ],
            "returns": [
              {
                "description": "something. todo."
              }
            ],
            "examples": [
              "to call with faceOrders create a copy of faceOrders and remove\nthe [2] third index for \"pairs\"."
            ],
            "name": "getDisjointedVertices",
            "longname": "getDisjointedVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getDuplicateEdges": {
          "jsdocs": {
            "description": "Get the indices of all duplicate edges by marking the\nsecond/third/... as duplicate (not the first of the duplicates).\nThe result is given as an array with holes, where:\n- the indices are the indices of the duplicate edges.\n- the values are the indices of the first occurence of the duplicate.\nUnder this system, many edges can be duplicates of the same edge.\nOrder is not important. [5,9] and [9,5] are still duplicate.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array where the redundant edges are the indices,\nand the values are the indices of the first occurence of the duplicate."
              }
            ],
            "examples": [
              "{number[]} array, [4:3, 7:5, 8:3, 12:3, 14:9] where indices\n(3, 4, 8, 12) are all duplicates. (5,7), (9,14) are also duplicates."
            ],
            "name": "getDuplicateEdges",
            "longname": "getDuplicateEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getDuplicateVertices": {
          "jsdocs": {
            "description": "Get the indices of all vertices which lie close to other vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "arrays of clusters of similar vertices. todo check this"
              }
            ],
            "name": "getDuplicateVertices",
            "longname": "getDuplicateVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getEdgeIsolatedVertices": {
          "jsdocs": {
            "description": "Get the indices of all vertices which make no appearance in any edge.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the indices of the isolated vertices"
              }
            ],
            "name": "getEdgeIsolatedVertices",
            "longname": "getEdgeIsolatedVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getEdgesEdgesOverlapingSpans": {
          "jsdocs": {
            "description": "Calculate every edge's rectangular bounding box and compare every box to\nevery box to determine if boxes overlap. This doesn't claim edges overlap, only that\ntheir bounding boxes do, and that two edges *might* overlap.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon to be added as padding to the bounding boxes",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "NxN 2D array filled with true/false answering\n\"do edges's bounding boxes overlap?\"\nBoth triangles of the matrix are filled and the main diagonal contains true.\n```text\n    0  1  2  3\n0 [ t,  ,  ,  ]\n1 [  , t,  ,  ]\n2 [  ,  , t,  ]\n3 [  ,  ,  , t]\n```"
              }
            ],
            "name": "getEdgesEdgesOverlapingSpans",
            "longname": "getEdgesEdgesOverlapingSpans",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getEdgesVerticesOverlappingSpan": {
          "jsdocs": {
            "description": "This returns a matrix relating every edge to every vertex,\nanswering the question \"does the vertex sit inside the edge's bounding box?\"\nIt doesn't solve if a vertex lies on an edge, only that it *might* lie along an edge.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon to be added as padding to the bounding boxes",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "array matching edges_ length where each value is\nan array matching vertices_ length, containing true/false."
              }
            ],
            "name": "getEdgesVerticesOverlappingSpan",
            "longname": "getEdgesVerticesOverlappingSpan",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getFaceFaceSharedVertices": {
          "jsdocs": {
            "description": "given two faces, get the vertices which are shared between the two faces.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the faces_vertices entry for face A",
                "name": "face_a_vertices"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the faces_vertices entry for face B",
                "name": "face_b_vertices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "indices of vertices that are shared between faces maintaining\nthe vertices in the same order as the winding order of face A."
              }
            ],
            "name": "getFaceFaceSharedVertices",
            "longname": "getFaceFaceSharedVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getFaceIsolatedVertices": {
          "jsdocs": {
            "description": "Get the indices of all vertices which make no appearance in any face.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the indices of the isolated vertices"
              }
            ],
            "name": "getFaceIsolatedVertices",
            "longname": "getFaceIsolatedVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getFacesFaces2DOverlap": {
          "jsdocs": {
            "description": "Compare every face to every face to answer: do the two faces overlap?\nReturn the result in the form of a matrix, an array of arrays of booleans,\nwhere both halves of the matrix are filled, matrix[i][j] === matrix[j][i].",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "face-face matrix answering: do they overlap?"
              }
            ],
            "name": "getFacesFaces2DOverlap",
            "longname": "getFacesFaces2DOverlap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getGraphKeysWithPrefix": {
          "jsdocs": {
            "description": "Get all keys in a graph which contain a \"_\" prefixed by the provided string.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a prefix to match against the keys",
                "name": "prefix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of keys that start with the prefix\nfor example: \"vertices\" will return:\nvertices_coords, vertices_faces,\nbut not edges_vertices, or verticesCoords (must end with _)"
              }
            ],
            "name": "getGraphKeysWithPrefix",
            "longname": "getGraphKeysWithPrefix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getGraphKeysWithSuffix": {
          "jsdocs": {
            "description": "Get all keys in a graph which contain a \"_\" followed by the provided suffix.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a suffix to match against the keys",
                "name": "suffix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of keys that end with the suffix\nfor example: \"vertices\" will return:\nedges_vertices, faces_vertices,\nbut not vertices_coords, or edgesvertices (must prefix with _)"
              }
            ],
            "name": "getGraphKeysWithSuffix",
            "longname": "getGraphKeysWithSuffix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getIsolatedVertices": {
          "jsdocs": {
            "description": "Get the indices of all vertices which make no appearance in any edge or face.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the indices of the isolated vertices"
              }
            ],
            "name": "getIsolatedVertices",
            "longname": "getIsolatedVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getLongestArray": {
          "jsdocs": {
            "description": "This will iterate over the array of arrays and returning\nthe first array in the list with the longest length.",
            "params": [
              {
                "type": {
                  "names": [
                    "any[][]"
                  ]
                },
                "description": "an array of arrays of any type",
                "name": "arrays"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "any[]"
                  ]
                },
                "description": "one of the arrays from the set"
              }
            ],
            "name": "getLongestArray",
            "longname": "getLongestArray",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getOverlappingFacesGroups": {
          "jsdocs": {
            "description": "For every face, gather all other faces which not only lie in\nthe same plane in 3D space, but also overlap this face.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array matching the length of faces, for every face,\nthe list of indices of faces which overlap this face."
              }
            ],
            "name": "getOverlappingFacesGroups",
            "longname": "getOverlappingFacesGroups",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getPlanarBoundary": {
          "jsdocs": {
            "description": "Get the boundary as two arrays of vertices and edges\nby walking the boundary edges in 2D and uncovering the concave hull.\nDoes not consult edges_assignment, but does require vertices_coords.\nFor repairing crease patterns, this will uncover boundary edges_assignments.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph\n(vertices_coords, vertices_vertices, edges_vertices)\n(vertices edges only required in case vertices_vertices needs to be built)",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "\"vertices\" and \"edges\" with arrays of indices."
              }
            ],
            "name": "getPlanarBoundary",
            "longname": "getPlanarBoundary",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getVerticesClusters": {
          "jsdocs": {
            "description": "Find all clusters of vertices which lie within an epsilon of each other.\nEach cluster is an array of vertex indices. If no clusters exist, the method returns\nN-number of arrays, each with a single vertex entry.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of arrays of vertex indices."
              }
            ],
            "examples": [
              "no clusters: [ [0], [1], [2], [3], [4], ... ]\nclusters: [ [0, 5], [1], [3], [2, 4]]"
            ],
            "name": "getVerticesClusters",
            "longname": "getVerticesClusters",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getVerticesEdgesOverlap": {
          "jsdocs": {
            "description": "Get a list of lists where for every edge there is a\nlist filled with vertices that lies collinear to the edge, where\ncollinearity only counts if the vertex lies between the edge's endpoints,\nexcluding the endpoints themselves.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "size matched to the edges_ arrays, with an empty array\nunless a vertex lies collinear, the edge's array will contain that vertex's index."
              }
            ],
            "name": "getVerticesEdgesOverlap",
            "longname": "getVerticesEdgesOverlap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "intersectConvexFaceLine": {
          "jsdocs": {
            "description": "intersect a convex face with a line and return the location\nof the intersections as components of the graph. this is an EXCLUSIVE\nintersection. line collinear to the edge counts as no intersection.\nthere are 5 cases:\n- no intersection (undefined)\n- intersect one vertex (undefined)\n- intersect two vertices (valid, or undefined if neighbors)\n- intersect one vertex and one edge (valid)\n- intersect two edges (valid)",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the index of the face",
                "name": "face"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector component describing the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a point that lies along the line",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object",
                    "undefined"
                  ]
                },
                "description": "\"vertices\" and \"edges\" keys, indices of the\ncomponents which intersect the line. or undefined if no intersection"
              }
            ],
            "name": "intersectConvexFaceLine",
            "longname": "intersectConvexFaceLine",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "invertMap": {
          "jsdocs": {
            "description": "invert an array of integers so that indices become values and\nvalues become indices. in the case of multiple values trying to insert\ninto the same index, a child array is made to house both (or more) numbers.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "number[][]"
                  ]
                },
                "description": "an array of integers",
                "name": "map"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "number[][]"
                  ]
                },
                "description": "the inverted map"
              }
            ],
            "name": "invertMap",
            "longname": "invertMap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "invertSimpleMap": {
          "jsdocs": {
            "description": "invert an array of integers so that indices become values\nand values become indices. duplicate entries will be overwritten.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of integers",
                "name": "map"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the inverted map"
              }
            ],
            "name": "invertSimpleMap",
            "longname": "invertSimpleMap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "isFoldedForm": {
          "jsdocs": {
            "description": "Check a FOLD object's frame_classes for the presence of \"foldedForm\".",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the graph is folded."
              }
            ],
            "name": "isFoldedForm",
            "longname": "isFoldedForm",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "isFoldObject": {
          "jsdocs": {
            "description": "Using heuristics, try to determine if an object is a FOLD object.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "value between 0 and 1, zero meaning no chance, one meaning 100% chance"
              }
            ],
            "name": "isFoldObject",
            "longname": "isFoldObject",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "isVertexCollinear": {
          "jsdocs": {
            "description": "determine if a vertex exists between two and only two edges, and\nthose edges are both parallel and on opposite ends of the vertex. In a lot of\ncases, this vertex can be removed and the graph would function the same.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "an index of a vertex in the graph",
                "name": "vertex"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the vertex is collinear and can be removed."
              }
            ],
            "name": "isVertexCollinear",
            "longname": "isVertexCollinear",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "kite": {
          "jsdocs": {
            "description": "Create a kite base FOLD object, in crease pattern form.",
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "kite",
            "longname": "Create.kite",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "makeEdgesAssignment": {
          "jsdocs": {
            "description": "Convert edges fold angle into assignment for every edge. This method\nwill assign \"M\" \"V\" \"F\" and \"B\" for edges with only one incident face.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, with edges_foldAngle",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of fold assignments"
              }
            ],
            "name": "makeEdgesAssignment",
            "longname": "makeEdgesAssignment",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesAssignmentSimple": {
          "jsdocs": {
            "description": "Convert edges fold angle into assignment for every edge. This simple\nmethod will only result in \"M\" \"V\" and \"F\", depending on crease angle.\n\"makeEdgesAssignment()\" will also assign \"B\"",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, with edges_foldAngle",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of fold assignments"
              }
            ],
            "name": "makeEdgesAssignmentSimple",
            "longname": "makeEdgesAssignmentSimple",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesBoundingBox": {
          "jsdocs": {
            "description": "Make an array of axis-aligned bounding boxes, one for each edge,\nthat encloses the edge, and will work in n-dimensions. Intended for\nfast line-sweep algorithms.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph with vertices and edges.",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of boxes, length matching the number of edges"
              }
            ],
            "name": "makeEdgesBoundingBox",
            "longname": "makeEdgesBoundingBox",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesCoords": {
          "jsdocs": {
            "description": "map vertices_coords onto edges_vertices so that the result\nis an edge array where each edge contains its two points. Each point being\nthe 2D or 3D coordinate as an array of numbers.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph with vertices and edges",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][][]"
                  ]
                },
                "description": "an array of array of points (which are arrays of numbers)"
              }
            ],
            "name": "makeEdgesCoords",
            "longname": "makeEdgesCoords",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesEdges": {
          "jsdocs": {
            "description": "Make `edges_edges` containing all vertex-adjacent edges.\nThis will be radially sorted if you call makeVerticesEdges before calling this.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, with entries edges_vertices, vertices_edges",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "each entry relates to an edge, each array contains indices\nof other edges."
              }
            ],
            "name": "makeEdgesEdges",
            "longname": "makeEdgesEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesEdges2DParallel": {
          "jsdocs": {
            "name": "makeEdgesEdges2DParallel",
            "longname": "makeEdgesEdges2DParallel",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeEdgesEdgesCrossing": {
          "jsdocs": {
            "description": "Find all edges which cross other edges, \"cross\" meaning\nthe segment overlaps the other segment in a non-parallel way. This also\nexcludes the epsilon space around the endpoints so that adjacent edges\nare automatically considered not crossing. All parallel line pairs,\neven if overlapping, are marked false.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD graph.",
                "name": "fold"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon with a default value of 1e-6",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "a boolean matrix, do two edges cross each other?"
              }
            ],
            "name": "makeEdgesEdgesCrossing",
            "longname": "makeEdgesEdgesCrossing",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesEdgesIntersection": {
          "jsdocs": {
            "description": "This method compares every edge against every edge (n^2) to see if the\nsegments exclusively intersect each other (touching endpoints doesn't count)",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph. only requires { edges_vector, edges_origin }\nif they don't exist this will build them from { vertices_coords, edges_vertices }",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][][]"
                  ]
                },
                "description": "NxN matrix comparing indices, undefined in the case of\nno intersection, a point object in array form if yes, and this array is stored\nin 2 PLACES! both [i][j] and [j][i], however it is stored by reference,\nit is the same js object.\n    0  1  2  3\n0 [  , x,  ,  ]\n1 [ x,  ,  , x]\n2 [  ,  ,  ,  ]\n3 [  , x,  ,  ]"
              }
            ],
            "name": "makeEdgesEdgesIntersection",
            "longname": "makeEdgesEdgesIntersection",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesEdgesParallel": {
          "jsdocs": {
            "description": "Create an NxN matrix (N number of edges) that relates edges to each other,\ninside each entry is true/false, true if the two edges are parallel within an epsilon.\nBoth sides of the matrix are filled, the diagonal is left undefined.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "a boolean matrix, are two edges parallel?"
              }
            ],
            "todo": [
              "wait, no, this is not setting the main diagonal undefined now. what is up?"
            ],
            "name": "makeEdgesEdgesParallel",
            "longname": "makeEdgesEdgesParallel",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesEdgesParallelOverlap": {
          "jsdocs": {
            "description": "Find all edges which are parallel to each other AND they overlap.\nThe epsilon space around vertices is not considered, so, edges must be\ntruly overlapping for them to be true.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "a boolean matrix, do two edges cross each other?"
              }
            ],
            "name": "makeEdgesEdgesParallelOverlap",
            "longname": "makeEdgesEdgesParallelOverlap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesEdgesSimilar": {
          "jsdocs": {
            "description": "Similar edges are defined by their coordinates, it doesn't matter\nthe order, so long as the two endpoints match",
            "name": "makeEdgesEdgesSimilar",
            "longname": "makeEdgesEdgesSimilar",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeEdgesFaces": {
          "jsdocs": {
            "description": "Make `edges_faces` where each edge is paired with its incident faces.\nThis is sorted according to the FOLD spec, sorting faces on either side of an edge.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, with entries vertices_coords,\nedges_vertices, faces_vertices, faces_edges",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "each entry relates to an edge, each array contains indices\nof adjacent faces."
              }
            ],
            "name": "makeEdgesFaces",
            "longname": "makeEdgesFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesFacesOverlap": {
          "jsdocs": {
            "description": "Return an ExF matrix (number of: E=edges, F=faces), relating every edge\nto every face. Value will contain true if the edge and face overlap each other, excluding\nthe space around the edge's endpoints, and the edges of the face.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[][]"
                  ]
                },
                "description": "matrix relating edges to faces, answering, do they overlap?"
              }
            ],
            "name": "makeEdgesFacesOverlap",
            "longname": "makeEdgesFacesOverlap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesFacesUnsorted": {
          "jsdocs": {
            "description": "Make `edges_faces` where each edge is paired with its incident faces.\nThis is unsorted, prefer makeEdgesFaces()",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, with entries edges_vertices, faces_edges",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "each entry relates to an edge, each array contains indices\nof adjacent faces."
              }
            ],
            "name": "makeEdgesFacesUnsorted",
            "longname": "makeEdgesFacesUnsorted",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesFoldAngle": {
          "jsdocs": {
            "description": "Convert edges assignment into fold angle in degrees for every edge.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, with edges_assignment",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of fold angles in degrees"
              }
            ],
            "name": "makeEdgesFoldAngle",
            "longname": "makeEdgesFoldAngle",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesFoldAngleFromFaces": {
          "jsdocs": {
            "description": "Inspecting adjacent faces, and referencing their normals, infer\nthe foldAngle for every edge. This will result in a negative number for\nmountain creases, and positive for valley. This works well for 3D models,\nbut will fail for flat-folded models, in which case, edges_assignment\nwill be consulted to differentiate between 180 degree M or V folds.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "for every edge, an angle in degrees."
              }
            ],
            "name": "makeEdgesFoldAngleFromFaces",
            "longname": "makeEdgesFoldAngleFromFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesIsFolded": {
          "jsdocs": {
            "description": "For every edge, give us a boolean:\n- \"true\" if the edge is folded, valley or mountain, or unassigned.\n- \"false\" if the edge is not folded, flat or boundary.\n\"unassigned\" is considered folded so that an unsolved crease pattern\ncan be fed into here and we still compute the folded state.\nHowever, if there is no edges_assignments, and we have to use edges_foldAngle,\nthe \"unassigned\" trick will no longer work, only +/- non zero numbers get\ncounted as folded edges (true).\nFor this reason, treating \"unassigned\" as a folded edge, this method's\nfunctionality is better considered to be specific to makeFacesMatrix2,\ninstead of a generalized method.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "for every edge, is it folded? or has the potential to be folded?\n\"unassigned\"=yes"
              }
            ],
            "name": "makeEdgesIsFolded",
            "longname": "makeEdgesIsFolded",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesLength": {
          "jsdocs": {
            "description": "For every edge, find the length between the edges pair of vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with vertices_coords, edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the distance between each edge's pair of vertices"
              }
            ],
            "name": "makeEdgesLength",
            "longname": "makeEdgesLength",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesLineParallelOverlap": {
          "jsdocs": {
            "description": "Find all edges in a graph which lie parallel along a line (infinite line).",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a line defined by a vector crossing a point",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a line defined by a vector crossing a point",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "length matching number of edges, true if parallel and overlapping"
              }
            ],
            "name": "makeEdgesLineParallelOverlap",
            "longname": "makeEdgesLineParallelOverlap",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesSegmentIntersection": {
          "jsdocs": {
            "description": "Find all edges in a graph which lie parallel along a segment, the\nendpoints of the segments and the edges are inclusive.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "FOLD graph",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the first point of the segment",
                "name": "point1,"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the second point of the segment",
                "name": "point2,"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array length matching number of edges containing a point\nif there is an intersection, and undefined if no intersection."
              }
            ],
            "name": "makeEdgesSegmentIntersection",
            "longname": "makeEdgesSegmentIntersection",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeEdgesVector": {
          "jsdocs": {
            "description": "Turn every edge into a vector, basing the direction on the order of\nthe pair of vertices in each edges_vertices entry.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with vertices_coords, edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "each entry relates to an edge, each array contains a 2D vector"
              }
            ],
            "name": "makeEdgesVector",
            "longname": "makeEdgesVector",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesCenter2D": {
          "jsdocs": {
            "description": "For every face, get the face's centroid.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with vertices_coords, faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points, where each point is an array of numbers"
              }
            ],
            "name": "makeFacesCenter2D",
            "longname": "makeFacesCenter2D",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesConvexCenter": {
          "jsdocs": {
            "description": "This uses point average, not centroid, faces must\nbe convex, and again it's not precise, but in many use cases\nthis is often more than sufficient.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with vertices_coords, faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points, where each point is an array of numbers"
              }
            ],
            "name": "makeFacesConvexCenter",
            "longname": "makeFacesConvexCenter",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesEdgesFromVertices": {
          "jsdocs": {
            "description": "Make `faces_edges` from `faces_vertices`.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a `faces_edges` array"
              }
            ],
            "name": "makeFacesEdgesFromVertices",
            "longname": "makeFacesEdgesFromVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesFaces": {
          "jsdocs": {
            "description": "faces_faces is an array of edge-adjacent face indices for each face.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "each index relates to a face, each entry is an array\nof numbers, each number is an index of an edge-adjacent face to this face."
              }
            ],
            "name": "makeFacesFaces",
            "longname": "makeFacesFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesMatrix": {
          "jsdocs": {
            "description": "Create a transformation matrix for every face by virtually folding\nthe graph along all of the creases (this works in 3D too). This traverses\na face-adjacency tree (edge-adjacent faces) and recursively applies the\naffine transform that represents a fold across the edge between the faces.\n\"flat\" creases are ignored.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the index of the face that will remain in place",
                "name": "root_face"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "for every face, a 3x4 matrix (an array of 12 numbers)."
              }
            ],
            "name": "makeFacesMatrix",
            "longname": "makeFacesMatrix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesMatrix2": {
          "jsdocs": {
            "description": "This ignores any 3D data, and treats all creases as flat-folded.\nThis will generate a 2D matrix for every face by virtually folding the graph\nat every edge according to the assignment or foldAngle.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the index of the face that will remain in place",
                "name": "root_face"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "for every face, a 2x3 matrix (an array of 6 numbers)."
              }
            ],
            "name": "makeFacesMatrix2",
            "longname": "makeFacesMatrix2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesNormal": {
          "type": "Function"
        },
        "makeFaceSpanningTree": {
          "jsdocs": {
            "description": "Make a minimum spanning tree of a graph that edge-adjacent faces.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the face index to be the root node",
                "name": "root_face"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[][]"
                  ]
                },
                "description": "a tree arranged as an array containin arrays of nodes. each inner\narray contains all nodes at that depth (0, 1, 2...) each node contains:\n\"face\" {number} \"parent\" {number} \"edge_vertices\" {number[]}"
              }
            ],
            "name": "makeFaceSpanningTree",
            "longname": "makeFaceSpanningTree",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesPolygon": {
          "jsdocs": {
            "description": "map vertices_coords onto each face's set of vertices,\nturning each face into an array of points, with an additional step:\nensure that each polygon has 0 collinear vertices.\nthis can result in a polygon with fewer vertices than is contained\nin that polygon's faces_vertices array.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with vertices_coords, faces_vertices",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][][]"
                  ]
                },
                "description": "array of array of points, where each point is an array of numbers"
              }
            ],
            "name": "makeFacesPolygon",
            "longname": "makeFacesPolygon",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesPolygonQuick": {
          "jsdocs": {
            "description": "map vertices_coords onto each face's set of vertices,\nturning each face into an array of points. \"Quick\" meaning collinear vertices are\nnot removed, which in some cases, this will be the preferred method.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with vertices_coords, faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][][]"
                  ]
                },
                "description": "array of array of points, where each point is an array of numbers"
              }
            ],
            "name": "makeFacesPolygonQuick",
            "longname": "makeFacesPolygonQuick",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesVerticesFromEdges": {
          "jsdocs": {
            "description": "Make `faces_vertices` from `faces_edges`.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with faces_edges, edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a `faces_vertices` array"
              }
            ],
            "name": "makeFacesVerticesFromEdges",
            "longname": "makeFacesVerticesFromEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesWinding": {
          "jsdocs": {
            "description": "For every face, return a boolean if the face's vertices are\nin counter-clockwise winding. For origami models, this translates to\ntrue meaning the face is upright, false meaning the face is flipped over.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "boolean for every face, true if face is counter-clockwise."
              }
            ],
            "name": "makeFacesWinding",
            "longname": "makeFacesWinding",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesWindingFromMatrix": {
          "jsdocs": {
            "description": "For every face, return a boolean indicating if the face has\nbeen flipped over or not (false=flipped), by using the faces_matrix and\nchecking the determinant.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "for every face, a 3x4 transform matrix",
                "name": "faces_matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "true if a face is counter-clockwise."
              }
            ],
            "name": "makeFacesWindingFromMatrix",
            "longname": "makeFacesWindingFromMatrix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeFacesWindingFromMatrix2": {
          "jsdocs": {
            "description": "For every face, return a boolean indicating if the face has\nbeen flipped over or not (false=flipped), by using a faces_matrix containing\n2D matrices.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "for every face, a 2x3 transform matrix",
                "name": "faces_matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean[]"
                  ]
                },
                "description": "true if a face is counter-clockwise."
              }
            ],
            "name": "makeFacesWindingFromMatrix2",
            "longname": "makeFacesWindingFromMatrix2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePlanarFaces": {
          "jsdocs": {
            "description": "Rebuild all faces in a 2D planar graph by walking counter-clockwise\ndown every edge (both ways). This does not include the outside face which winds\naround the boundary backwards enclosing the outside space.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "array of faces as objects containing \"vertices\" \"edges\" and \"angles\""
              }
            ],
            "examples": [
              "// to convert the return object into faces_vertices and faces_edges\nvar faces = makePlanarFaces(graph);\nfaces_vertices = faces.map(el => el.vertices);\nfaces_edges = faces.map(el => el.edges);"
            ],
            "name": "makePlanarFaces",
            "longname": "makePlanarFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesCoordsFlatFolded": {
          "jsdocs": {
            "description": "Fold a graph along its edges and return the position of the folded\nvertices. this method works for 2D only (no z value).\nif a edges_assignment is \"U\", assumed to be folded (\"V\" or \"M\").\nFinally, if no edge foldAngle or assignments exist, this method will\nassume all edges are flat-folded (except boundary) and will fold everything.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the index of the face that will remain in place",
                "name": "root_face"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a new set of `vertices_coords` with the new positions."
              }
            ],
            "name": "makeVerticesCoordsFlatFolded",
            "longname": "makeVerticesCoordsFlatFolded",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesCoordsFolded": {
          "jsdocs": {
            "description": "Fold a graph along its edges and return the position\nof the folded vertices. This method works in both 2D and 3D\nunassigned edges are treated as flat fold (mountain/valley 180deg)\nas a way of (assuming the user is giving a flat folded origami), help\nsolve things about an origami that is currently being figured out.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the index of the face that will remain in place",
                "name": "root_face"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a new set of `vertices_coords` with the new positions."
              }
            ],
            "name": "makeVerticesCoordsFolded",
            "longname": "makeVerticesCoordsFolded",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesEdges": {
          "jsdocs": {
            "description": "Make `vertices_edges` sorted, so that the edges are sorted\nradially around the vertex, corresponding with the order in `vertices_vertices`.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing edges_vertices, vertices_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of numbers, where each row corresponds to a\nvertex index and the values in the inner array are edge indices."
              }
            ],
            "name": "makeVerticesEdges",
            "longname": "makeVerticesEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesEdgesUnsorted": {
          "jsdocs": {
            "description": "Make `vertices_edges` from `edges_vertices`, unsorted, which should\nbe used sparingly. Prefer makeVerticesEdges().",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of numbers, where each row corresponds to a\nvertex index and the values in the inner array are edge indices."
              }
            ],
            "name": "makeVerticesEdgesUnsorted",
            "longname": "makeVerticesEdgesUnsorted",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesFaces": {
          "jsdocs": {
            "description": "Make `vertices_faces` sorted counter-clockwise.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing vertices_coords, vertices_vertices, faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of numbers, where each row corresponds to a\nvertex index and the values in the inner array are face indices."
              }
            ],
            "name": "makeVerticesFaces",
            "longname": "makeVerticesFaces",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesFacesUnsorted": {
          "jsdocs": {
            "description": "Make `vertices_faces` **not sorted** counter-clockwise,\nwhich should be used sparingly. Prefer makeVerticesFaces().",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing vertices_coords, faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of numbers, where each row corresponds to a\nvertex index and the values in the inner array are face indices."
              }
            ],
            "name": "makeVerticesFacesUnsorted",
            "longname": "makeVerticesFacesUnsorted",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesNormal": {
          "type": "Function"
        },
        "makeVerticesSectors": {
          "jsdocs": {
            "description": "Between pairs of counter-clockwise adjacent edges around a vertex\nis the sector measured in radians. This builds an array of of sector angles,\nindex matched to vertices_vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing vertices_coords, vertices_vertices, edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of numbers, where each row corresponds\nto a vertex index, inner arrays contains angles in radians"
              }
            ],
            "name": "makeVerticesSectors",
            "longname": "makeVerticesSectors",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesToEdge": {
          "jsdocs": {
            "description": "Make an object which answers the question: \"which edge connects\nthese two vertices?\". This is accomplished by building an object with keys\ncontaining vertex pairs (space separated string), and the value is the edge index.\nThis is not bidirectional, so \"7 15\" can exist while \"15 7\" does not. This is useful\nfor example for looking up the edge's vector, which is direction specific.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "space-separated vertex pair keys, edge indices values"
              }
            ],
            "name": "makeVerticesToEdge",
            "longname": "makeVerticesToEdge",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesToEdgeBidirectional": {
          "jsdocs": {
            "description": "Make an object which answers the question: \"which edge connects\nthese two vertices?\". This is accomplished by building an object with keys\ncontaining vertex pairs (space separated string), and the value is the edge index.\nThis is bidirectional, so \"7 15\" and \"15 7\" are both keys that point to the same edge.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "space-separated vertex pair keys, edge indices values"
              }
            ],
            "name": "makeVerticesToEdgeBidirectional",
            "longname": "makeVerticesToEdgeBidirectional",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesToFace": {
          "jsdocs": {
            "description": "Make an object which answers the question: \"which face contains these\n3 consecutive vertices? (3 vertices in sequential order, from two adjacent edges)\"\nThe keys are space-separated trios of vertex indices, 3 vertices which\nare found when walking a face. These 3 vertices uniquely point to one and only one\nface, and the counter-clockwise walk direction is respected, this is not\nbidirectional, and does not contain the opposite order of the same 3 vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing faces_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "space-separated vertex trio keys, face indices values"
              }
            ],
            "name": "makeVerticesToFace",
            "longname": "makeVerticesToFace",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesVertices": {
          "jsdocs": {
            "description": "Make `vertices_vertices` sorted radially counter-clockwise.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing vertices_coords, vertices_edges, edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of array of numbers, where each row corresponds to a\nvertex index and the values in the inner array are vertex indices."
              }
            ],
            "name": "makeVerticesVertices",
            "longname": "makeVerticesVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeVerticesVerticesUnsorted": {
          "type": "Function"
        },
        "makeVerticesVerticesVector": {
          "jsdocs": {
            "description": "For every vertex, make an array of vectors that point towards each\nof the incident vertices. This is accomplised by taking the vertices_vertices\narray and converting it into vectors, indices will be aligned with vertices_vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, containing vertices_coords, vertices_vertices, edges_vertices",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][][]"
                  ]
                },
                "description": "array of array of array of numbers, where each row corresponds\nto a vertex index, inner arrays correspond to vertices_vertices, and inside is a 2D vector"
              }
            ],
            "todo": [
              "this can someday be rewritten without edges_vertices"
            ],
            "name": "makeVerticesVerticesVector",
            "longname": "makeVerticesVerticesVector",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "mergeBackmaps": {
          "jsdocs": {
            "description": "Provide two or more  backmaps in the order they were made\nand this will merge them into one backmap which reflects all changes to the graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "variable": true,
                "description": "a sequence of backmaps",
                "name": "...maps"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "one backmap reflecting the sum of changes"
              }
            ],
            "name": "mergeBackmaps",
            "longname": "mergeBackmaps",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "mergeNextmaps": {
          "jsdocs": {
            "description": "Provide two or more nextmaps in the order they were made\nand this will merge them into one nextmap which reflects all changes to the graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "variable": true,
                "description": "a sequence of nextmaps",
                "name": "...maps"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "one nextmap reflecting the sum of changes"
              }
            ],
            "name": "mergeNextmaps",
            "longname": "mergeNextmaps",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "mergeSimpleBackmaps": {
          "jsdocs": {
            "description": "Provide two or more simple backmaps in the order they were made\nand this will merge them into one backmap which reflects all changes to the graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "variable": true,
                "description": "a sequence of simplebackmaps",
                "name": "...maps"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one backmap reflecting the sum of changes"
              }
            ],
            "name": "mergeSimpleBackmaps",
            "longname": "mergeSimpleBackmaps",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "mergeSimpleNextmaps": {
          "jsdocs": {
            "description": "Provide two or more simple nextmaps in the order they were made\nand this will merge them into one nextmap which reflects all changes to the graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "variable": true,
                "description": "a sequence of simple nextmaps",
                "name": "...maps"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one nextmap reflecting the sum of changes"
              }
            ],
            "name": "mergeSimpleNextmaps",
            "longname": "mergeSimpleNextmaps",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyVerticesFacesMatrix2": {
          "jsdocs": {
            "description": "Given a FOLD object and a set of 2x3 matrices, one per face,\n\"fold\" the vertices by finding one matrix per vertex and multiplying them.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "graph with vertices_coords, faces_vertices, and\nif vertices_faces does not exist it will be built.",
                "name": "FOLD"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of 2x3 matrices. one per face.",
                "name": "an"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a new set of vertices_coords, transformed."
              }
            ],
            "name": "multiplyVerticesFacesMatrix2",
            "longname": "multiplyVerticesFacesMatrix2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearest": {
          "jsdocs": {
            "description": "Return an object which contains information regarding\nvertices, edges, and faces, which indices are closest to the provided point.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to find the nearest face",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "object which contains information about the nearest components,\nsome of which is stored in a getter, which delays the computation until called."
              }
            ],
            "name": "nearest",
            "longname": "nearest",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestEdge": {
          "jsdocs": {
            "description": "Iterate through all edges in a graph and find the one nearest to a provided point.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to find the nearest edge",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number",
                    "undefined"
                  ]
                },
                "description": "the index of the nearest edge, or undefined\nif there are no vertices_coords or edges_vertices"
              }
            ],
            "name": "nearestEdge",
            "longname": "nearestEdge",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestFace": {
          "jsdocs": {
            "description": "Iterate through all faces in a graph and find one nearest to a point.\nThis method assumes the graph is in 2D, it ignores any z components.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to find the nearest face",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number",
                    "undefined"
                  ]
                },
                "description": "the index of the face, or undefined if edges_faces is not defined."
              }
            ],
            "todo": [
              "make this work if edges_faces is not defined (not hard)"
            ],
            "name": "nearestFace",
            "longname": "nearestFace",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestVertex": {
          "jsdocs": {
            "description": "Iterate through all vertices in a graph and find the one nearest to a\nprovided point. This is the only of the \"nearest\" graph operations that works in 3D.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to find the nearest vertex",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the index of the nearest vertex"
              }
            ],
            "todo": [
              "improve with space partitioning"
            ],
            "name": "nearestVertex",
            "longname": "nearestVertex",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nonUniqueElements": {
          "jsdocs": {
            "description": "Given an array of any type, return the same array but filter\nout any items which only appear once. The comparison uses conversion-to-string,\nthen matching to compare, so this works for primitives\n(bool, number, string), not objects or arrays.",
            "params": [
              {
                "type": {
                  "names": [
                    "any[]"
                  ]
                },
                "description": "an array of any type.",
                "name": "array"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "any[]"
                  ]
                },
                "description": "the same input array but filtered to\nremove elements which appear only once."
              }
            ],
            "examples": [
              "[1,2,3,2,1] will result in [1,2,2,1]"
            ],
            "name": "nonUniqueElements",
            "longname": "nonUniqueElements",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "planarVertexWalk": {
          "jsdocs": {
            "description": "Given a planar graph, discover all faces by counter-clockwise walking\nby starting at every edge.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of face objects, where each face has number arrays,\n\"vertices\", \"edges\", and \"angles\". vertices and edges are indices, angles are radians."
              }
            ],
            "name": "planarVertexWalk",
            "longname": "planarVertexWalk",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "polygon": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a polygon defined by a sequence of points. This comes with\nobject methods and can be used in intersection calculations. The polygon can be non-convex,\nbut some methods only work on convex polygons.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "...Array.<number>"
                  ]
                },
                "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "polygon"
                  ]
                },
                "description": "one polygon object"
              }
            ],
            "name": "polygon",
            "longname": "ear.polygon",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "populate": {
          "jsdocs": {
            "description": "Populate all arrays in a FOLD graph. This includes building adjacency\ncomponents like vertices_vertices, making edges_assignments from foldAngles or\nvisa-versa, and building faces if they don't exist.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "optional": true,
                "defaultvalue": false,
                "description": "optional boolean, request to rebuild all faces",
                "name": "reface"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "graph the same input graph object"
              }
            ],
            "name": "populate",
            "longname": "populate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "rectangle": {
          "jsdocs": {
            "description": "Create a new FOLD object which contains one rectangular face,\nincluding vertices and boundary edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the width of the rectangle",
                "name": "width"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the height of the rectangle",
                "name": "height"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "rectangle",
            "longname": "Create.rectangle",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "remove": {
          "jsdocs": {
            "name": "remove",
            "memberof": "graph",
            "description": "Removes vertices, edges, or faces (or anything really)\nremove elements from inside arrays, shift up remaining components,\nand updates all relevant references across other arrays due to shifting.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "like \"vertices\", the prefix of the arrays",
                "name": "key"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of vertex indices, like [1,9,25]",
                "name": "removeIndices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a map of changes to the graph"
              }
            ],
            "examples": [
              "remove(foldObject, \"vertices\", [2,6,11,15]);",
              "removing index 5 from a 10-long vertices list will shift all\nindices > 5 up by one, and then will look through all other arrays like\nedges_vertices, faces_vertices and update any reference to indices 6-9\nto match their new positions 5-8.\n\nthis can handle removing multiple indices at once; and is faster than\notherwise calling this multiple times with only one or a few removals.",
              "given removeIndices: [4, 6, 7];\ngiven a geometry array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nmap becomes (_=undefined): [0, 1, 2, 3, _, 4, _, _, 5, 6];"
            ],
            "scope": "static",
            "longname": "graph.remove",
            "kind": "member"
          },
          "type": "Function"
        },
        "removeCircularEdges": {
          "jsdocs": {
            "description": "Find and remove all circular edges from a graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "description": "Leave this empty. Otherwise, if\ngetCircularEdges() has already been called, provide the result here to speed\nup the algorithm.",
                "name": "remove_indices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a summary of changes"
              }
            ],
            "name": "removeCircularEdges",
            "longname": "removeCircularEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "removeDuplicateEdges": {
          "jsdocs": {
            "description": "Find and remove all duplicate edges from a graph.\nIf an edge is removed, it will mess up the vertices data (vertices_vertices,\nvertices_edges, vertices_faces) so if this method successfully found and\nremoved a duplicate edge, the vertices arrays will be rebuilt as well.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "description": "Leave this empty. Otherwise, if\ngetDuplicateEdges() has already been called, provide the result here to speed\nup the algorithm.",
                "name": "replace_indices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a summary of changes"
              }
            ],
            "name": "removeDuplicateEdges",
            "longname": "removeDuplicateEdges",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "removeDuplicateVertices": {
          "jsdocs": {
            "description": "This will shrink the number of vertices in the graph,\nif vertices are close within an epsilon, it will keep the first one,\nfind the average of close points, and assign it to the remaining vertex.\n**this has the potential to create circular and duplicate edges**.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "summary of changes"
              }
            ],
            "name": "removeDuplicateVertices",
            "longname": "removeDuplicateVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "removeIsolatedVertices": {
          "jsdocs": {
            "description": "Remove any vertices which are not a part of any edge or\nface. This will shift up the remaining vertices indices so that the\nvertices arrays will not have any holes, and, additionally it searches\nthrough all _vertices reference arrays and updates the index\nreferences for the shifted vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "description": "Leave this empty. Otherwise, if\ngetIsolatedVertices() has already been called, provide the result here to speed\nup the algorithm.",
                "name": "remove_indices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "summary of changes"
              }
            ],
            "name": "removeIsolatedVertices",
            "longname": "removeIsolatedVertices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "removePlanarEdge": {
          "jsdocs": {
            "description": "remove an edge from a planar graph, rebuild affected faces,\nremove any newly isolated vertices.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the index of the edge to be removed",
                "name": "edge"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "undefined"
                  ]
                }
              }
            ],
            "name": "removePlanarEdge",
            "longname": "removePlanarEdge",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "removePlanarVertex": {
          "jsdocs": {
            "description": "given a degree-2 vertex, remove this vertex, merge the adjacent\nedges into one, and rebuild the faces on either side.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the index of the edge to be removed",
                "name": "edge"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "undefined"
                  ]
                }
              }
            ],
            "name": "removePlanarVertex",
            "longname": "removePlanarVertex",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "replace": {
          "jsdocs": {
            "name": "replace",
            "memberof": "graph",
            "description": "Replaces vertices, edges, or faces (or anything really)\nreplace elements from inside arrays, shift up remaining components,\nand updates all relevant references across other arrays due to shifting.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "like \"vertices\", the prefix of the arrays",
                "name": "key"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of vertex indices, like [1,9,25]",
                "name": "replaceIndices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a map of changes to the graph"
              }
            ],
            "examples": [
              "replace(foldObject, \"vertices\", [2,6,11,15]);",
              "for example: removing index 5 from a 10-long vertices list will shift all\nindices > 5 up by one, and then will look through all other arrays like\nedges_vertices, faces_vertices and update any reference to indices 6-9\nto match their new positions 5-8.\n\nthis can handle removing multiple indices at once; and is faster than\notherwise calling this multiple times with only one or a few removals."
            ],
            "scope": "static",
            "longname": "graph.replace",
            "kind": "member"
          },
          "type": "Function"
        },
        "rotateZ": {
          "jsdocs": {
            "name": "rotateZ",
            "memberof": "graph",
            "description": "apply a rotation to a graph around the +Z axis.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "rotation amount in radians",
                "name": "the"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array or series of numbers, the center of rotation",
                "name": "optional."
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "the same input graph, modified"
              }
            ],
            "scope": "static",
            "longname": "graph.rotateZ",
            "kind": "member"
          },
          "type": "Function"
        },
        "scale": {
          "jsdocs": {
            "name": "scale",
            "memberof": "graph",
            "description": "apply a uniform affine scale to a graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the scale amount",
                "name": "scale"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array or series of numbers, the center of scale.",
                "name": "optional."
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "the same input graph, modified."
              }
            ],
            "scope": "static",
            "longname": "graph.scale",
            "kind": "member"
          },
          "type": "Function"
        },
        "selfRelationalUniqueIndexPairs": {
          "jsdocs": {
            "description": "Given a self-relational array of arrays, for example,\nvertices_vertices, edges_edges, faces_faces, where the values in the\ninner arrays relate to the indices of the outer array, create a list of\nall pairwise combinations of related indices. This handles circular\nreferences, and ensures that no duplicate pairs appear by maintaining\nfor [i, j] that i <= j.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of arrays of integers",
                "name": "array_array"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of two-dimensional array pairs of indices."
              }
            ],
            "name": "selfRelationalUniqueIndexPairs",
            "longname": "selfRelationalUniqueIndexPairs",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "sortVerticesAlongVector": {
          "jsdocs": {
            "description": "sort a subset of vertices from a graph along a vector.\neg: given the vector [1,0], points according to their X value.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the indices of vertices to be sorted",
                "name": "vertices"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a vector along which to sort vertices",
                "name": "vector"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "indices of vertices, in sorted order"
              }
            ],
            "name": "sortVerticesAlongVector",
            "longname": "sortVerticesAlongVector",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "sortVerticesCounterClockwise": {
          "jsdocs": {
            "description": "This is a subroutine for building vertices_vertices. This will\ntake a set of vertices indices and a vertex index to be the center point, and\nsort the indices radially counter-clockwise.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of vertex indices to be sorted",
                "name": "vertices"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the origin vertex, around which the vertices will be sorted",
                "name": "vertex"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "indices of vertices, in sorted order"
              }
            ],
            "name": "sortVerticesCounterClockwise",
            "longname": "sortVerticesCounterClockwise",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "splitCircularArray": {
          "jsdocs": {
            "description": "A circular array (data wraps around) requires 2 indices\nif you intend to split it into two arrays. The pair of indices can be\nprovided in any order, they will be sorted, smaller index first.",
            "params": [
              {
                "type": {
                  "names": [
                    "any[]"
                  ]
                },
                "description": "an array that is meant to be thought of as circular",
                "name": "array"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "two numbers, indices that divide the array into 2 parts",
                "name": "indices"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "any[][]"
                  ]
                },
                "description": "the same array split into two arrays"
              }
            ],
            "name": "splitCircularArray",
            "longname": "splitCircularArray",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "splitEdge": {
          "jsdocs": {
            "description": "split an edge with a new vertex, replacing the old\nedge with two new edges sharing the common vertex. rebuilding:\n- vertices_coords, vertices_vertices, vertices_edges, vertices_faces,\n- edges_vertices, edges_faces, edges_assignment,\n- edges_foldAngle, edges_vector\n- faces_vertices, faces_edges,\nwithout rebuilding:\n- faces_faces\ntodo: edgeOrders",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "FOLD object, modified in place",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "index of old edge to be split",
                "name": "old_edge"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "coordinates of the new vertex to be added. optional.\nif omitted, a vertex will be generated at the edge's midpoint.",
                "name": "coords"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "if an incident vertex is within this distance\nthe function will not split the edge, simply return this vertex.",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a summary of the changes with keys \"vertex\", \"edges\"\n\"vertex\" is the index of the new vertex (or old index, if similar)\n\"edge\" is a summary of changes to edges, with \"map\" and \"remove\""
              }
            ],
            "name": "splitEdge",
            "longname": "splitEdge",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "splitFace": {
          "jsdocs": {
            "description": "divide a **convex** face into two polygons with a straight line cut.\nif the line ends exactly along existing vertices, they will be\nused, otherwise, new vertices will be added (splitting edges).",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object, modified in place",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "index of face to split",
                "name": "face"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector component of the cutting line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point component of the cutting line",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object",
                    "undefined"
                  ]
                },
                "description": "a summary of changes to the FOLD object,\n or undefined if no change (no intersection)."
              }
            ],
            "name": "splitFace",
            "longname": "splitFace",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "square": {
          "jsdocs": {
            "description": "Create a new FOLD object which contains one square face,\nincluding vertices and boundary edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the length of the sides.",
                "name": "scale"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "square",
            "longname": "Create.square",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "subgraph": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "subgraph",
            "longname": "subgraph",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "svg": {
          "jsdocs": {
            "name": "svg",
            "memberof": "graph",
            "description": "renders a FOLD object as an SVG, ensuring visibility by\nsetting the viewBox and the stroke-width attributes on the SVG.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "nullable": true,
                "description": "optional options object to style components",
                "name": "options"
              },
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "the draw method to resize the viewbox/stroke",
                "name": "tell"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "SVGElement"
                  ]
                },
                "description": "SVG element, containing the rendering of the origami."
              }
            ],
            "scope": "static",
            "longname": "graph.svg",
            "kind": "member"
          },
          "children": {
            "boundaries": {
              "type": "Function"
            },
            "drawInto": {
              "jsdocs": {
                "name": "drawInto",
                "memberof": "graph",
                "description": "renders a FOLD object into an SVG, ensuring visibility by\nsetting the viewBox and the stroke-width attributes on the SVG.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "SVGElement"
                      ]
                    },
                    "description": "an already initialized SVG DOM element.",
                    "name": "element"
                  },
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD object",
                    "name": "graph"
                  },
                  {
                    "type": {
                      "names": [
                        "object"
                      ]
                    },
                    "description": "an optional options object to style the rendering",
                    "name": "options"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "SVGElement"
                      ]
                    },
                    "description": "the first SVG parameter object."
                  }
                ],
                "scope": "static",
                "longname": "graph.drawInto",
                "kind": "member"
              },
              "type": "Function"
            },
            "edges": {
              "jsdocs": {
                "description": "Get the number of edges in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of edges in the graph"
                  }
                ],
                "name": "edges",
                "longname": "count.edges",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "faces": {
              "jsdocs": {
                "description": "Get the number of faces in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of faces in the graph"
                  }
                ],
                "name": "faces",
                "longname": "count.faces",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "getViewBox": {
              "type": "Function"
            },
            "vertices": {
              "jsdocs": {
                "description": "Get the number of vertices in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of vertices in the graph"
                  }
                ],
                "name": "vertices",
                "longname": "count.vertices",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            }
          },
          "type": "Function"
        },
        "transform": {
          "jsdocs": {
            "name": "transform",
            "memberof": "graph",
            "description": "apply an affine transform to a graph; this includes\nmodifying the position of any key ending with \"_coords\" and multiplying\nany matrix in keys that end with \"_matrix\".",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 3x4 matrix as a 12 number array",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "the same input graph, modified"
              }
            ],
            "scope": "static",
            "longname": "graph.transform",
            "kind": "member"
          },
          "type": "Function"
        },
        "translate": {
          "jsdocs": {
            "name": "translate",
            "memberof": "graph",
            "description": "apply a translation to a graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array or series of numbers, the translation vector",
                "name": "optional."
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "the same input graph, modified"
              }
            ],
            "scope": "static",
            "longname": "graph.translate",
            "kind": "member"
          },
          "type": "Function"
        },
        "transposeGraphArrayAtIndex": {
          "jsdocs": {
            "description": "This takes in a geometry_key (vectors, edges, faces), and flattens\nacross all related arrays, creating one object with the keys.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a geometry item like \"vertices\"",
                "name": "geometry_key"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "index of an element",
                "name": "the"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "an object with FOLD keys but the values are from this single element"
              }
            ],
            "name": "transposeGraphArrayAtIndex",
            "longname": "transposeGraphArrayAtIndex",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "transposeGraphArrays": {
          "jsdocs": {
            "description": "This takes in a geometry_key (vectors, edges, faces), and flattens\nacross all related arrays, creating one object with the keys for every index.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a geometry item like \"vertices\"",
                "name": "geometry_key"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of objects with FOLD keys but the\nvalues are from this single element"
              }
            ],
            "name": "transposeGraphArrays",
            "longname": "transposeGraphArrays",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "triangulate": {
          "type": "Function"
        },
        "triangulateConvexFacesVertices": {
          "type": "Function"
        },
        "uniqueElements": {
          "jsdocs": {
            "description": "Given a list of any type, remove all duplicates.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of integers",
                "name": "array"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "set of unique integers"
              }
            ],
            "examples": [
              "[1,2,3,2,1] will result in [1,2,3]"
            ],
            "name": "uniqueElements",
            "longname": "uniqueElements",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "uniqueSortedNumbers": {
          "jsdocs": {
            "description": "Given a list of integers (can contain duplicates),\nthis will return a sorted set of unique integers (removing duplicates).",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of integers",
                "name": "array"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "set of sorted, unique integers"
              }
            ],
            "examples": [
              "[3,2,1,2,3] will result in [1,2,3]"
            ],
            "name": "uniqueSortedNumbers",
            "longname": "uniqueSortedNumbers",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validate": {
          "jsdocs": {
            "description": "Validate an axiom, this will run one of the submethods (\"validateAxiom1\", ...).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the axiom number, 1-7",
                "name": "number"
              },
              {
                "type": {
                  "names": [
                    "AxiomParams"
                  ]
                },
                "description": "the axiom parameters, lines and points in one object",
                "name": "params"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "boundary"
              },
              {
                "type": {
                  "names": [
                    "line[]"
                  ]
                },
                "description": "the solutions from the axiom method (before validation)",
                "name": "solutions"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean",
                    "boolean[]"
                  ]
                },
                "description": "for every solution, true if valid. Axioms 1, 2, 4, 7\nreturn one boolean, 3, 5, 6 return arrays of booleans."
              }
            ],
            "name": "validate",
            "longname": "validate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        }
      },
      "type": "Function"
    },
    "intersect": {
      "jsdocs": {
        "name": "intersect",
        "description": "get the intersection of two geometry objects, the type of each is inferred.",
        "params": [
          {
            "type": {
              "names": [
                "any"
              ]
            },
            "description": "any geometry object",
            "name": "a"
          },
          {
            "type": {
              "names": [
                "any"
              ]
            },
            "description": "any geometry object",
            "name": "b"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "optional": true,
            "defaultvalue": "1e-6",
            "description": "optional epsilon",
            "name": "epsilon"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "number[]",
                "number[][]",
                "undefined"
              ]
            },
            "description": "the type of the result varies depending on\nthe type of the input parameters, it is always one point, or an array of points,\nor undefined if no intersection."
          }
        ],
        "longname": "intersect",
        "kind": "member",
        "scope": "global"
      },
      "type": "Function"
    },
    "layer": {
      "jsdocs": {
        "description": "A collection of methods for calculating the layer order\nof the faces of an origami in its folded state.",
        "name": "layer",
        "longname": "layer",
        "kind": "member",
        "scope": "global",
        "params": []
      },
      "children": {
        "faceOrdersToMatrix": {
          "jsdocs": {
            "description": "Convert a set of face-pair layer orders (+1,-1,0)\ninto a face-face relationship matrix.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of FOLD spec faceOrders.",
                "name": "faceOrders"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "NxN matrix, number of faces, containing +1,-1,0\nas values showing the relationship between i to j in face[i][j]."
              }
            ],
            "name": "faceOrdersToMatrix",
            "longname": "faceOrdersToMatrix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "facesLayerToEdgesAssignments": {
          "jsdocs": {
            "description": "Given a faces_layer ordering of faces in a graph,\ncomplute the edges_assignments, including \"B\", \"F\", \"V\", and \"M\".",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph, with the vertices already folded.",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a faces_layer array",
                "name": "faces_layer"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "an edges_assignment array."
              }
            ],
            "name": "facesLayerToEdgesAssignments",
            "longname": "facesLayerToEdgesAssignments",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "flipFacesLayer": {
          "jsdocs": {
            "description": "Flip a model over by reversing the order of the faces\nin a faces_layer encoding.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a faces_layer array",
                "name": "faces_layer"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a new faces_layer array"
              }
            ],
            "name": "flipFacesLayer",
            "longname": "flipFacesLayer",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "foldStripWithAssignments": {
          "jsdocs": {
            "description": "Given an array of sectors (defined by length),\nand a fenceposted-array of fold assignments, fold the sectors\nalong the numberline, returning each sector as a pair of numbers\nthat mark the two ends of the of the folded sector: [end1, end2].\nThe first sector is always starts at 0, and spans [0, sector].\n\nWhen a boundary edge is encountered, the walk stops, no sectors after\nthe boundary will be included in the result. The algorithm will walk in\none direction, incrementing, starting at index \"start\", stopping at \"end\".",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of sector lengths",
                "name": "faces"
              },
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of assignments \"B\", \"V\", \"M\", \"F\"",
                "name": "an"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of sector positions with two indices representing\neither end of the sector. any sectors caught between multiple\nboundaries will be undefined."
              }
            ],
            "name": "foldStripWithAssignments",
            "longname": "foldStripWithAssignments",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nudgeFacesWithFaceOrders": {
          "jsdocs": {
            "description": "Given a graph which contains a faceOrders, get an array\nof information for each face, what is its displacement vector, and\nwhat is its displacement magnitude integer, indicating which layer\nthis face lies on.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph with faceOrders.",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of objects, one for every face, each\nwith properties \"vector\" and \"layer\"."
              }
            ],
            "name": "nudgeFacesWithFaceOrders",
            "longname": "nudgeFacesWithFaceOrders",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nudgeFacesWithFacesLayer": {
          "jsdocs": {
            "description": "Given a graph with a faces_layer, a topological sorting\nof faces, for a flat-folded 2D graph, get an array where every face\nis given a layer and a vector, which will always be [0, 0, 1].",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph with the parameter faces_layer.",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of objects, one for every face, each\nwith properties \"vector\" and \"layer\"."
              }
            ],
            "name": "nudgeFacesWithFacesLayer",
            "longname": "nudgeFacesWithFacesLayer",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "singleVertexAssignmentSolver": {
          "jsdocs": {
            "name": "singleVertexAssignmentSolver",
            "description": "This extends the singleVertexSolver to also solve unassigned\nassignments. The assignments parameter can be left empty entirely, or,\nif you only know some assignments, place \"U\" in the unknown spots.\nfaces and assignments are fencepost aligned. assignments precedes faces.\n      faces: |-----(0)-----(1)-----(2)---- ... -(n-2)-------(n-1)-|\nassignments: |-(0)-----(1)-----(2)-----(3) ... -------(n-1)-------|",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an ordered list of scalars, the lengths of the faces",
                "name": "orderedScalars"
              },
              {
                "type": {
                  "names": [
                    "string[]",
                    "undefined"
                  ]
                },
                "description": "an array of single character assignment values",
                "name": "assignments"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "array of solutions where each solution contains\n\"layer\" and \"assignment\", where layer is a \"faces_layer\" mapping, and assignment\nis an array of assignment characters."
              }
            ],
            "longname": "singleVertexAssignmentSolver",
            "kind": "member",
            "scope": "global"
          },
          "type": "Function"
        },
        "singleVertexSolver": {
          "jsdocs": {
            "description": "Given an ordered set of faces and crease assignments\nbetween the faces, this recursive algorithm finds every combination\nof layer orderings that work without causing any self-intersections.\n\"scalars\" could be sector angles, where the sum of angles doesn't need to\nadd up to 360, or this method can solve a strip of paper where \"scalars\"\nis not radial, simply 1D lengths between folds.\nIf \"scalars\" represents a 1D folded strip which does not loop around, make\nsure to include two \"B\" assignments in the correct location.\nfaces and assignments are fencepost aligned. assignments precedes faces.\nfaces: |-----(0)-----(1)-----(2)---- ... -(n-2)-------(n-1)-|\nassig: |-(0)-----(1)-----(2)-----(3) ... -------(n-1)-------|",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "unsigned scalars, the length of paper between folds",
                "name": "ordered"
              },
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "of \"M\",\"V\", assignment of fold between faces",
                "name": "array"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of arrays. each inner array is a solution.\neach solution is an ordering of faces_layer, where each index is a\nface and each value is the layer the face occupies."
              }
            ],
            "name": "singleVertexSolver",
            "longname": "singleVertexSolver",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "solver": {
          "jsdocs": {
            "name": "solver",
            "memberof": "layer",
            "description": "Recursively calculate all layer order solutions between faces\nin a flat-folded FOLD graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a flat-folded FOLD graph, where the vertices\nhave already been folded.",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a set of solutions where keys are face pairs\nand values are +1 or -1 describing the relationship of the two faces.\nResults are stored in \"root\" and \"partitions\", to compile a complete solution,\nappend the \"root\" to one selection from each array in \"partitions\"."
              }
            ],
            "scope": "static",
            "longname": "layer.solver",
            "kind": "member"
          },
          "type": "Function"
        },
        "solver2d": {
          "jsdocs": {
            "name": "solver2d",
            "memberof": "layer",
            "description": "Recursively calculate all layer order solutions between faces\nin a flat-folded FOLD graph.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a flat-folded FOLD graph, where the vertices\nhave already been folded.",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a set of solutions where keys are face pairs\nand values are +1 or -1 describing the relationship of the two faces.\nResults are stored in \"root\" and \"branches\", to compile a complete solution,\nappend the \"root\" to one selection from each array in \"branches\"."
              }
            ],
            "scope": "static",
            "longname": "layer.solver2d",
            "kind": "member"
          },
          "type": "Function"
        },
        "topologicalOrder": {
          "jsdocs": {
            "description": "find a topological ordering from a set of facePairOrders",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a solution of face layer facePairOrders where\nthe keys are space-separated pair of faces, and the value is +1 0 or -1.",
                "name": "facePairOrders"
              },
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "an optional FOLD graph",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "layers_face, for every layer (key) which face (value) inhabits it."
              }
            ],
            "name": "topologicalOrder",
            "longname": "topologicalOrder",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        }
      },
      "type": "undefined"
    },
    "line": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a line defined by a vector and a point passing through the line.\nThis object comes with object methods and can be used in intersection calculations.",
        "params": [
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the line's vector",
            "name": "vector"
          },
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the line's origin (without this, it will assumed to be the origin)",
            "name": "origin"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "line"
              ]
            },
            "description": "one line object"
          }
        ],
        "name": "line",
        "longname": "ear.line",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "math": {
      "jsdocs": {
        "description": "A collection of math functions with a focus on linear algebra,\ncomputational geometry, intersection of shapes, and some origami-specific operations.",
        "name": "math",
        "longname": "math",
        "kind": "constant",
        "scope": "global",
        "params": []
      },
      "children": {
        "D2R": {
          "jsdocs": {
            "description": "degrees to radians",
            "name": "D2R",
            "longname": "D2R",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Number"
        },
        "EPSILON": {
          "jsdocs": {
            "description": "this epsilon is used throughout the library",
            "name": "EPSILON",
            "longname": "EPSILON",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Number"
        },
        "identity2x2": {
          "jsdocs": {
            "description": "the identity matrix for 2x2 matrices",
            "name": "identity2x2",
            "longname": "identity2x2",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Array"
        },
        "identity2x3": {
          "jsdocs": {
            "description": "the identity matrix for 2x3 matrices (zero translation)",
            "name": "identity2x3",
            "longname": "identity2x3",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Array"
        },
        "identity3x3": {
          "jsdocs": {
            "description": "the identity matrix for 3x3 matrices",
            "name": "identity3x3",
            "longname": "identity3x3",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Array"
        },
        "identity3x4": {
          "jsdocs": {
            "description": "the identity matrix for 3x4 matrices (zero translation)",
            "name": "identity3x4",
            "longname": "identity3x4",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Array"
        },
        "identity4x4": {
          "jsdocs": {
            "description": "the identity matrix for 3x3 matrices",
            "name": "identity4x4",
            "longname": "identity4x4",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Array"
        },
        "R2D": {
          "jsdocs": {
            "description": "radians to degrees",
            "name": "R2D",
            "longname": "R2D",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Number"
        },
        "TWO_PI": {
          "jsdocs": {
            "description": "pi x 2",
            "name": "TWO_PI",
            "longname": "TWO_PI",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Number"
        },
        "add": {
          "jsdocs": {
            "description": "add two vectors and return the sum as another vector,\ndo not modify the input vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, dimension matching first parameter"
              }
            ],
            "name": "add",
            "longname": "add",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "add2": {
          "jsdocs": {
            "description": "add two vectors and return the sum as another vector,\ndo not modify the input vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "add2",
            "longname": "add2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "add3": {
          "jsdocs": {
            "description": "add two vectors and return the sum as another vector,\ndo not modify the input vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector"
              }
            ],
            "name": "add3",
            "longname": "add3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "average": {
          "jsdocs": {
            "description": "the average of N number of vectors, similar to midpoint,\nbut can accept more than 2 inputs",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "any number of input vectors",
                "name": "...args"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, dimension matching first parameter"
              }
            ],
            "name": "average",
            "longname": "average",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "bisectLines2": {
          "jsdocs": {
            "description": "given two lines, find two lines which bisect the given lines,\nif the given lines have an intersection, or return one line if they are parallel.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector of the first line, as an array of numbers",
                "name": "vectorA"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin of the first line, as an array of numbers",
                "name": "originA"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector of the first line, as an array of numbers",
                "name": "vectorB"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin of the first line, as an array of numbers",
                "name": "originB"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon for testing parallel-ness.",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "an array of objects with \"vector\" and \"origin\" keys defining a line"
              }
            ],
            "name": "bisectLines2",
            "longname": "bisectLines2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "boundingBox": {
          "jsdocs": {
            "description": "Make an axis-aligned bounding box that encloses a set of points.\nthe optional padding is used to make the bounding box inclusive / exclusive\nby adding padding on all sides, or inset in the case of negative number.\n(positive=inclusive boundary, negative=exclusive boundary)",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of unsorted points, in any dimension",
                "name": "points"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "optionally add padding around the box",
                "name": "padding"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "BoundingBox"
                  ]
                },
                "nullable": true,
                "description": "an object where \"min\" and \"max\" are two points and\n\"span\" is the lengths. returns \"undefined\" if no points were provided."
              }
            ],
            "name": "boundingBox",
            "longname": "boundingBox",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "centroid": {
          "jsdocs": {
            "description": "Calculates the centroid or the center of mass of the polygon.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of 2D points, which are arrays of numbers",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point as an array of numbers"
              }
            ],
            "examples": [
              "var centroid = polygon.centroid([ [1,2], [8,9], [8,0] ])"
            ],
            "name": "centroid",
            "longname": "centroid",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "circumcircle": {
          "jsdocs": {
            "description": "Calculates the circumcircle which lies on three points.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point as an array of numbers",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point as an array of numbers",
                "name": "b"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point as an array of numbers",
                "name": "c"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "circle"
                  ]
                },
                "description": "one circle with keys \"radius\" (number) and \"origin\" (number[])"
              }
            ],
            "name": "circumcircle",
            "longname": "circumcircle",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "cleanNumber": {
          "jsdocs": {
            "description": "clean floating point numbers, where 15.0000000000000002 becomes 15,\nthis method involves encoding and parsing so it is relatively expensive.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the floating point number to clean",
                "name": "num"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 15,
                "description": "the whole number of decimal places to\nkeep, beyond this point can be considered to be noise.",
                "name": "places"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the cleaned floating point number"
              }
            ],
            "name": "cleanNumber",
            "longname": "cleanNumber",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clipLineConvexPolygon": {
          "jsdocs": {
            "description": "find the overlap between one line and one convex polygon and\nclip the line into a segment (two endpoints) or return undefined if no overlap.\nThe input line can be a line, ray, or segment, as determined by \"fnLine\".",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points (which are arrays of numbers)",
                "name": "poly"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector of the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin of the line",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "defaultvalue": "include",
                "description": "include or exclude polygon boundary in clip",
                "name": "fnPoly"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "defaultvalue": "includeL",
                "description": "function to determine line/ray/segment,\nand inclusive or exclusive.",
                "name": "fnLine"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "optional epsilon",
                "name": "epsilon"
              }
            ],
            "name": "clipLineConvexPolygon",
            "longname": "clipLineConvexPolygon",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clipPolygonPolygon": {
          "jsdocs": {
            "description": "clip two polygons and return their union. this works for non-convex\npoylgons, but both polygons must have counter-clockwise winding; will not work\neven if both are similarly-clockwise. Sutherland-Hodgman algorithm.\nImplementation is from Rosetta Code, refactored to include an epsilon.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, where each point is an array of numbers.",
                "name": "polygon1"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, where each point is an array of numbers.",
                "name": "polygon2"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a polygon as an array of points."
              }
            ],
            "name": "clipPolygonPolygon",
            "longname": "clipPolygonPolygon",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clockwiseAngle2": {
          "jsdocs": {
            "description": "There are 2 interior angles between 2 vectors, A-to-B clockwise,\nand A-to-B counter-clockwise. Get the clockwise one from A to B.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector as an array of two numbers",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector as an array of two numbers",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "interior angle in radians, clockwise from a to b"
              }
            ],
            "name": "clockwiseAngle2",
            "longname": "clockwiseAngle2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clockwiseAngleRadians": {
          "jsdocs": {
            "description": "There are 2 interior angles between 2 vectors (as an angle in radians),\nA-to-B clockwise, and A-to-B counter-clockwise. Get the clockwise one from A to B.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "vector as an angle in radians",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "vector as an angle in radians",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "interior angle in radians"
              }
            ],
            "name": "clockwiseAngleRadians",
            "longname": "clockwiseAngleRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clockwiseBisect2": {
          "jsdocs": {
            "description": "calculate the angle bisection clockwise from the first vector to the second.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "clockwiseBisect2",
            "longname": "clockwiseBisect2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clockwiseSubsect2": {
          "jsdocs": {
            "description": "subsect into n-divisions the angle clockwise from one vector to the next",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "number of angles minus 1",
                "name": "divisions"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector in array form",
                "name": "vectorA"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector in array form",
                "name": "vectorB"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of vectors (which are arrays of numbers)"
              }
            ],
            "name": "clockwiseSubsect2",
            "longname": "clockwiseSubsect2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clockwiseSubsectRadians": {
          "jsdocs": {
            "description": "subsect into n-divisions the angle clockwise from one angle to the next",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "number of angles minus 1",
                "name": "divisions"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one angle in radians",
                "name": "angleA"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one angle in radians",
                "name": "angleB"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of angles in radians"
              }
            ],
            "name": "clockwiseSubsectRadians",
            "longname": "clockwiseSubsectRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "clusterIndicesOfSortedNumbers": {
          "jsdocs": {
            "description": "given an array of already-sorted values (so that comparisons only\nneed to happen between neighboring items), cluster the numbers which are similar\nwithin an epsilon. isolated values still get put in length-1 arrays. (all values returned)\nand the clusters contain the indices from the param array, not the values.",
            "params": [
              {
                "type": {
                  "names": [
                    "numbers[]"
                  ]
                },
                "description": "array of sorted numbers",
                "name": "an"
              },
              {
                "type": {
                  "names": [
                    "numbers"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "numbers[][]"
                  ]
                },
                "description": "an array of arrays, each inner array containin indices.\neach inner array represents clusters of values which lie within an epsilon."
              }
            ],
            "name": "clusterIndicesOfSortedNumbers",
            "longname": "clusterIndicesOfSortedNumbers",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "collinearBetween": {
          "jsdocs": {
            "description": "Check if a point is collinear and between two other points.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a segment point",
                "name": "p0"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to test collinearity",
                "name": "p1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a segment point",
                "name": "p2"
              },
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "optional": true,
                "defaultvalue": false,
                "description": "if the point is the same as the endpoints",
                "name": "inclusive"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the point lies collinear and between the other two points."
              }
            ],
            "name": "collinearBetween",
            "longname": "collinearBetween",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "convexHull": {
          "jsdocs": {
            "description": "Convex hull from a set of 2D points, choose whether to include or exclude\npoints which lie collinear inside one of the boundary lines. modified Graham scan algorithm.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points, each point is an array of numbers",
                "name": "points"
              },
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "optional": true,
                "defaultvalue": false,
                "description": "true to include points collinear along the boundary",
                "name": "includeCollinear"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "undefined behavior when larger than 0.01",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "the convex hull as a list of points,\nwhere each point is an array of numbers"
              }
            ],
            "name": "convexHull",
            "longname": "convexHull",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "convexHullIndices": {
          "jsdocs": {
            "description": "Convex hull from a set of 2D points, choose whether to include or exclude\npoints which lie collinear inside one of the boundary lines. modified Graham scan algorithm.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points, each point is an array of numbers",
                "name": "points"
              },
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "optional": true,
                "defaultvalue": false,
                "description": "true to include points collinear along the boundary",
                "name": "includeCollinear"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "undefined behavior when larger than 0.01",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "not the points, but the indices of points in your \"points\" array"
              }
            ],
            "name": "convexHullIndices",
            "longname": "convexHullIndices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseAngle2": {
          "jsdocs": {
            "description": "There are 2 interior angles between 2 vectors, A-to-B clockwise,\nand A-to-B counter-clockwise. Get the counter-clockwise one from A to B.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector as an array of two numbers",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector as an array of two numbers",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "interior angle in radians, counter-clockwise from a to b"
              }
            ],
            "name": "counterClockwiseAngle2",
            "longname": "counterClockwiseAngle2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseAngleRadians": {
          "jsdocs": {
            "description": "There are 2 interior angles between 2 vectors (as an angle in radians),\nA-to-B clockwise, and A-to-B counter-clockwise. Get the counter-clockwise one from A to B.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "vector as an angle in radians",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "vector as an angle in radians",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "interior angle in radians, counter-clockwise from a to b"
              }
            ],
            "name": "counterClockwiseAngleRadians",
            "longname": "counterClockwiseAngleRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseBisect2": {
          "jsdocs": {
            "description": "calculate the angle bisection counter-clockwise from the first vector to the second.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "counterClockwiseBisect2",
            "longname": "counterClockwiseBisect2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseOrder2": {
          "jsdocs": {
            "description": "sort an array of vectors by getting an array of\nreference indices to the input array, instead of a sorted array of vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of vectors (which are arrays of numbers)",
                "name": "args"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of indices of the input array, indicating\nthe counter-clockwise sorted arrangement."
              }
            ],
            "name": "counterClockwiseOrder2",
            "longname": "counterClockwiseOrder2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseOrderRadians": {
          "jsdocs": {
            "description": "sort an array of angles in radians by getting an array of\nreference indices to the input array, instead of an array of angles.\n\nmaybe there is such thing as an absolute radial origin (x axis?)\nbut this chooses the first element as the first element\nand sort everything else counter-clockwise around it.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "number"
                  ]
                },
                "description": "array or sequence of angles in radians",
                "name": "args"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of indices of the input array, indicating\nthe counter-clockwise sorted arrangement."
              }
            ],
            "name": "counterClockwiseOrderRadians",
            "longname": "counterClockwiseOrderRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseSectors2": {
          "jsdocs": {
            "description": "given an array of vectors, return the sector angles between\nconsecutive parameters. if radially unsorted, this will sort them.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of 2D vectors (higher dimensions will be ignored)",
                "name": "args"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of sector angles in radians"
              }
            ],
            "name": "counterClockwiseSectors2",
            "longname": "counterClockwiseSectors2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseSectorsRadians": {
          "jsdocs": {
            "description": "given an array of angles, return the sector angles between\nconsecutive parameters. if radially unsorted, this will sort them.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "number"
                  ]
                },
                "description": "array or sequence of angles in radians",
                "name": "args"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of sector angles in radians"
              }
            ],
            "name": "counterClockwiseSectorsRadians",
            "longname": "counterClockwiseSectorsRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseSubsect2": {
          "jsdocs": {
            "description": "subsect into n-divisions the angle counter-clockwise from one vector to the next",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "number of angles minus 1",
                "name": "divisions"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector in array form",
                "name": "vectorA"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector in array form",
                "name": "vectorB"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of vectors (which are arrays of numbers)"
              }
            ],
            "name": "counterClockwiseSubsect2",
            "longname": "counterClockwiseSubsect2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "counterClockwiseSubsectRadians": {
          "jsdocs": {
            "description": "subsect into n-divisions the angle counter-clockwise from one angle to the next",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "number of angles minus 1",
                "name": "divisions"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one angle in radians",
                "name": "angleA"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one angle in radians",
                "name": "angleB"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of angles in radians"
              }
            ],
            "name": "counterClockwiseSubsectRadians",
            "longname": "counterClockwiseSubsectRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "cross2": {
          "jsdocs": {
            "description": "the determinant of the matrix of the 2 vectors\n(possible bad name, 2D cross product is undefined)",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar; the determinant; the magnitude of the vector"
              }
            ],
            "name": "cross2",
            "longname": "cross2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "cross3": {
          "jsdocs": {
            "description": "the 3D cross product of two 3D vectors",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector"
              }
            ],
            "name": "cross3",
            "longname": "cross3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "degenerate": {
          "jsdocs": {
            "description": "check if a vector is degenerate, meaning its magnitude is below an epsilon limit.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon with a default value of 1e-6",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "is the magnitude of the vector smaller than the epsilon?"
              }
            ],
            "name": "degenerate",
            "longname": "degenerate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "determinant2": {
          "jsdocs": {
            "description": "calculate the determinant of a 2x3 or 2x2 matrix.\nin the case of 2x3, the translation component is ignored.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the determinant of the matrix"
              }
            ],
            "name": "determinant2",
            "longname": "determinant2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "determinant3": {
          "jsdocs": {
            "description": "calculate the determinant of a 3x4 or 3x3 matrix.\nin the case of 3x4, the translation component is ignored.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the determinant of the matrix"
              }
            ],
            "name": "determinant3",
            "longname": "determinant3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "determinant4": {
          "jsdocs": {
            "description": "calculate the determinant of a 4x4 or 3x3 matrix.\nin the case of 4x4, the translation component is ignored.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the determinant of the matrix"
              }
            ],
            "name": "determinant4",
            "longname": "determinant4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "distance": {
          "jsdocs": {
            "description": "compute the distance between two vectors",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "distance",
            "longname": "distance",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "distance2": {
          "jsdocs": {
            "description": "compute the distance between two 2D vectors",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "distance2",
            "longname": "distance2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "distance3": {
          "jsdocs": {
            "description": "compute the distance between two 3D vectors",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "distance3",
            "longname": "distance3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "dot": {
          "jsdocs": {
            "description": "compute the dot product of two vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "dot",
            "longname": "dot",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "dot2": {
          "jsdocs": {
            "description": "compute the dot product of two 2D vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "dot2",
            "longname": "dot2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "enclosingBoundingBoxes": {
          "jsdocs": {
            "name": "enclosingBoundingBoxes",
            "longname": "enclosingBoundingBoxes",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "enclosingPolygonPolygon": {
          "jsdocs": {
            "description": "does one polygon (outer) completely enclose another polygon (inner),\ncurrently, this only works for convex polygons.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a 2D convex polygon",
                "name": "outer"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a 2D convex polygon",
                "name": "inner"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "description": "by default, the boundary is considered inclusive",
                "name": "fnInclusive"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "is the \"inner\" polygon completely inside the \"outer\""
              }
            ],
            "name": "enclosingPolygonPolygon",
            "longname": "enclosingPolygonPolygon",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "exclude": {
          "jsdocs": {
            "description": "the exclusive test used in intersection algorithms, returns\ntrue if the number is positive, excluding the epsilon between 0 and +epsilon.",
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "-Infinity...{false}...+epsilon...{true}...+Infinity"
              }
            ],
            "name": "exclude",
            "longname": "exclude",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "excludeL": {
          "jsdocs": {
            "description": "the function parameter for an exclusive line",
            "name": "excludeL",
            "longname": "excludeL",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "excludeR": {
          "jsdocs": {
            "description": "the function parameter for an exclusive ray",
            "name": "excludeR",
            "longname": "excludeR",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "excludeS": {
          "jsdocs": {
            "description": "the function parameter for an exclusive segment",
            "name": "excludeS",
            "longname": "excludeS",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "flattenArrays": {
          "jsdocs": {
            "description": "totally flatten, recursive",
            "params": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "any array, intended to contain arrays of arrays.",
                "name": "args"
              }
            ],
            "returns": [
              {
                "description": "an array, always."
              }
            ],
            "name": "flattenArrays",
            "longname": "flattenArrays",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "flip": {
          "jsdocs": {
            "description": "return a copy of the input vector where each element's sign flipped",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, dimensions matching input parameter"
              }
            ],
            "name": "flip",
            "longname": "flip",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnAdd": {
          "jsdocs": {
            "description": "add two parameters",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "a number",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "a number",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "a number"
              }
            ],
            "name": "fnAdd",
            "longname": "fnAdd",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnAnd": {
          "jsdocs": {
            "description": "boolean AND the two inputs",
            "params": [
              {
                "type": {
                  "names": [
                    "any"
                  ]
                },
                "description": "any input",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "any"
                  ]
                },
                "description": "any input",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "the AND of both inputs"
              }
            ],
            "name": "fnAnd",
            "longname": "fnAnd",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnCat": {
          "jsdocs": {
            "description": "concat the two arrays, resulting in one joined array",
            "params": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "any array input",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "any array input",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "one joined array"
              }
            ],
            "name": "fnCat",
            "longname": "fnCat",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnEpsilonEqual": {
          "jsdocs": {
            "description": "Are two inputs equal within an epsilon of each other?",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "any number input",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "any number input",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the numbers are near each other"
              }
            ],
            "name": "fnEpsilonEqual",
            "longname": "fnEpsilonEqual",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnEpsilonEqualVectors": {
          "jsdocs": {
            "description": "are two vectors equal to each other within an epsilon. This method\nuses a fast rectangle-area around each vector.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of numbers",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of numbers",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the vectors are similar within an epsilon"
              }
            ],
            "name": "fnEpsilonEqualVectors",
            "longname": "fnEpsilonEqualVectors",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnEpsilonSort": {
          "jsdocs": {
            "description": "Sort two numbers within an epsilon of each other, so that \"1\": a < b,\n\"-1\": a > b, and \"0\": a ~= b (epsilon equal).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "any number",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "any number",
                "name": "b"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "-1, 0, +1"
              }
            ],
            "name": "fnEpsilonSort",
            "longname": "fnEpsilonSort",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnEqual": {
          "jsdocs": {
            "description": "Are two inputs equal using Javascript's triple equals?",
            "params": [
              {
                "type": {
                  "names": [
                    "any"
                  ]
                },
                "description": "any input",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "any"
                  ]
                },
                "description": "any input",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the inputs are equal"
              }
            ],
            "name": "fnEqual",
            "longname": "fnEqual",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnNotUndefined": {
          "jsdocs": {
            "description": "is an input not undefined? using Javascript's triple equals !==",
            "params": [
              {
                "type": {
                  "names": [
                    "any"
                  ]
                },
                "description": "any input",
                "name": "a"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the input is not undefined"
              }
            ],
            "name": "fnNotUndefined",
            "longname": "fnNotUndefined",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnSquare": {
          "jsdocs": {
            "description": "multiply a parameter by itself",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "a number",
                "name": "n"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "a number"
              }
            ],
            "name": "fnSquare",
            "longname": "fnSquare",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnToVec2": {
          "jsdocs": {
            "description": "Convert an angle in radians to a 2D vector.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle in radians",
                "name": "a"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 2D vector"
              }
            ],
            "name": "fnToVec2",
            "longname": "fnToVec2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "fnTrue": {
          "jsdocs": {
            "description": "trivial method, returns true",
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true"
              }
            ],
            "name": "fnTrue",
            "longname": "fnTrue",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "fnVec2Angle": {
          "jsdocs": {
            "description": "Convert a 2D vector to an angle in radians.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an input vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle in radians"
              }
            ],
            "name": "fnVec2Angle",
            "longname": "fnVec2Angle",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "getCircle": {
          "type": "Function"
        },
        "getLine": {
          "type": "Function"
        },
        "getMatrix3x4": {
          "jsdocs": {
            "description": "a matrix3 is a 4x3 matrix, 3x3 orientation with a column for translation",
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of 12 numbers, or undefined if bad inputs"
              }
            ],
            "name": "getMatrix3x4",
            "longname": "getMatrix3x4",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "getRay": {
          "type": "Function"
        },
        "getRect": {
          "type": "Function"
        },
        "getRectParams": {
          "type": "Function"
        },
        "getSegment": {
          "jsdocs": {
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "segment in array form [[a1, a2], [b1, b2]]"
              }
            ],
            "name": "getSegment",
            "longname": "getSegment",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "getVector": {
          "jsdocs": {
            "description": "search function arguments for a valid n-dimensional vector\ncan handle object-vector representation {x:, y:}",
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector in array form, or empty array for bad inputs"
              }
            ],
            "name": "getVector",
            "longname": "getVector",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "getVectorOfVectors": {
          "jsdocs": {
            "description": "search function arguments for a an array of vectors. a vector of vectors\ncan handle object-vector representation {x:, y:}",
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector in array form, or empty array for bad inputs"
              }
            ],
            "name": "getVectorOfVectors",
            "longname": "getVectorOfVectors",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "include": {
          "jsdocs": {
            "description": "the inclusive test used in intersection algorithms, returns\ntrue if the number is positive, including the epsilon between -epsilon and 0.",
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "-Infinity...{false}...-epsilon...{true}...+Infinity"
              }
            ],
            "name": "include",
            "longname": "include",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "includeL": {
          "jsdocs": {
            "description": "the function parameter for an inclusive line",
            "name": "includeL",
            "longname": "includeL",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "includeR": {
          "jsdocs": {
            "description": "the function parameter for an inclusive ray",
            "name": "includeR",
            "longname": "includeR",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "includeS": {
          "jsdocs": {
            "description": "the function parameter for an inclusive segment",
            "name": "includeS",
            "longname": "includeS",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "intersectCircleCircle": {
          "jsdocs": {
            "description": "calculate the intersection of two circles, resulting in either no intersection,\nor one or two points.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the first circle's radius",
                "name": "radius1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the first circle's origin",
                "name": "origin1"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the second circle's radius",
                "name": "radius2"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the second circle's origin",
                "name": "origin2"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "undefined"
                  ]
                },
                "description": "an array of one or two points, or undefined if no intersection"
              }
            ],
            "name": "intersectCircleCircle",
            "longname": "intersectCircleCircle",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "intersectCircleLine": {
          "jsdocs": {
            "description": "Calculate the intersection of a circle and a line; the line can\nbe a line, ray, or segment.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the circle's radius",
                "name": "circleRadius"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the center of the circle",
                "name": "circleOrigin"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector component of the line",
                "name": "lineVector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin component of the line",
                "name": "lineOrigin"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "defaultvalue": "includeL",
                "description": "set the line/ray/segment and inclusive/exclusive",
                "name": "lineFunc"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "name": "intersectCircleLine",
            "longname": "intersectCircleLine",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "intersectConvexPolygonLine": {
          "jsdocs": {
            "description": "generalized line-ray-segment intersection with convex polygon function\nfor lines and rays, line1 and line2 are the vector, origin in that order.\nfor segments, line1 and line2 are the two endpoints.\n\nthis doubles as the exclusive condition, and the main export since it\nchecks for exclusive/inclusive and can early-return",
            "name": "intersectConvexPolygonLine",
            "longname": "intersectConvexPolygonLine",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "intersectLineLine": {
          "jsdocs": {
            "description": "Find the intersection of two lines. Lines can be lines/rays/segments,\nand can be inclusve or exclusive in terms of their endpoints and the epsilon value.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of 2 numbers, the first line's vector",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of 2 numbers, the first line's origin",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of 2 numbers, the second line's vector",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "array of 2 numbers, the second line's origin",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "defaultvalue": "includeL",
                "description": "first line's boolean test normalized value lies collinear",
                "name": "aFunction"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "defaultvalue": "includeL",
                "description": "second line's boolean test normalized value lies collinear",
                "name": "bFunction"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "undefined"
                  ]
                },
                "description": "one 2D point or undefined"
              }
            ],
            "name": "intersectLineLine",
            "longname": "intersectLineLine",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "invertMatrix2": {
          "jsdocs": {
            "description": "invert a 2x3 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "undefined"
                  ]
                },
                "description": "the inverted matrix, or undefined if not possible"
              }
            ],
            "name": "invertMatrix2",
            "longname": "invertMatrix2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "invertMatrix3": {
          "jsdocs": {
            "description": "invert a 3x4 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "undefined"
                  ]
                },
                "description": "the inverted matrix, or undefined if not possible"
              }
            ],
            "name": "invertMatrix3",
            "longname": "invertMatrix3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "invertMatrix4": {
          "jsdocs": {
            "description": "invert a 4x4 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]",
                    "undefined"
                  ]
                },
                "description": "the inverted matrix, or undefined if not possible"
              }
            ],
            "name": "invertMatrix4",
            "longname": "invertMatrix4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "isCounterClockwiseBetween": {
          "jsdocs": {
            "description": "check if the first parameter is counter-clockwise between A and B.\nfloor and ceiling can be unbounded, this method takes care of 0-2pi wrap around.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "angle in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "angle in radians, lower bound",
                "name": "floor"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "angle in radians, upper bound",
                "name": "ceiling"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "is the angle between floor and ceiling"
              }
            ],
            "name": "isCounterClockwiseBetween",
            "longname": "isCounterClockwiseBetween",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "isIdentity3x4": {
          "jsdocs": {
            "description": "test if a 3x4 matrix is the identity matrix within an epsilon",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 3x4 matrix",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the matrix is the identity matrix"
              }
            ],
            "name": "isIdentity3x4",
            "longname": "isIdentity3x4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "isIdentity4x4": {
          "jsdocs": {
            "description": "test if a 4x4 matrix is the identity matrix within an epsilon",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 4x4 matrix",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the matrix is the identity matrix"
              }
            ],
            "name": "isIdentity4x4",
            "longname": "isIdentity4x4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "lerp": {
          "jsdocs": {
            "description": "linear interpolate between two vectors",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar between 0 and 1 (not clamped)",
                "name": "t"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, dimensions matching first parameter"
              }
            ],
            "name": "lerp",
            "longname": "lerp",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "lineLimiter": {
          "jsdocs": {
            "description": "These clamp functions process lines/rays/segments intersections.\nThe line method allows all values.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the length along the vector",
                "name": "t"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the clamped input value"
              }
            ],
            "name": "lineLimiter",
            "longname": "lineLimiter",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "magnitude": {
          "jsdocs": {
            "description": "compute the magnitude an n-dimensional vector",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "magnitude",
            "longname": "magnitude",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "magnitude2": {
          "jsdocs": {
            "description": "compute the magnitude a 2D vector",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "magnitude2",
            "longname": "magnitude2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "magnitude3": {
          "jsdocs": {
            "description": "compute the magnitude a 3D vector",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "magnitude3",
            "longname": "magnitude3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "magSquared": {
          "jsdocs": {
            "description": "compute the square-magnitude an n-dimensional vector",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar"
              }
            ],
            "name": "magSquared",
            "longname": "magSquared",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeLookAtMatrix4": {
          "jsdocs": {
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the location of the camera in 3D space",
                "name": "position"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point in space the camera is looking towards",
                "name": "target"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector pointing up out the top of the camera.",
                "name": "up"
              }
            ],
            "name": "makeLookAtMatrix4",
            "longname": "makeLookAtMatrix4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix2Reflect": {
          "jsdocs": {
            "description": "remember vector comes before origin. origin comes last, so that it's easy\nto leave it empty and make a reflection through the origin.",
            "params": [
              {
                "description": "in vector-origin form",
                "name": "line"
              }
            ],
            "returns": [
              {
                "description": "matrix"
              }
            ],
            "name": "makeMatrix2Reflect",
            "longname": "makeMatrix2Reflect",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix2Rotate": {
          "jsdocs": {
            "params": [
              {
                "description": "of rotation, origin of transformation",
                "name": "angle"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "matrix"
              }
            ],
            "name": "makeMatrix2Rotate",
            "longname": "makeMatrix2Rotate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix2Scale": {
          "jsdocs": {
            "params": [
              {
                "description": "of scale, optional origin homothetic center (0,0 default)",
                "name": "ratio"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "matrix"
              }
            ],
            "name": "makeMatrix2Scale",
            "longname": "makeMatrix2Scale",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix2Translate": {
          "jsdocs": {
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "y",
                "name": "x,"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "matrix"
              }
            ],
            "name": "makeMatrix2Translate",
            "longname": "makeMatrix2Translate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3ReflectZ": {
          "jsdocs": {
            "description": "make a 3x4 representing a reflection across a line in the XY plane\nThis is a 2D operation, assumes everything is in the XY plane.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector specifying the reflection axis",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0]",
                "description": "2D origin specifying a point of reflection",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3ReflectZ",
            "longname": "makeMatrix3ReflectZ",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3Rotate": {
          "jsdocs": {
            "description": "make a 3x4 matrix representing a rotation in 3D\naround a given vector and around a given center of rotation.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,1]",
                "description": "the axis of rotation",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3Rotate",
            "longname": "makeMatrix3Rotate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3RotateX": {
          "jsdocs": {
            "description": "make a 3x4 matrix representing a rotation in 3D around the x-axis\n(allowing you to specify the center of rotation if needed).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3RotateX",
            "longname": "makeMatrix3RotateX",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3RotateY": {
          "jsdocs": {
            "description": "make a 3x4 matrix representing a rotation in 3D around the y-axis\n(allowing you to specify the center of rotation if needed).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3RotateY",
            "longname": "makeMatrix3RotateY",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3RotateZ": {
          "jsdocs": {
            "description": "make a 3x4 matrix representing a rotation in 3D around the z-axis\n(allowing you to specify the center of rotation if needed).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3RotateZ",
            "longname": "makeMatrix3RotateZ",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3Scale": {
          "jsdocs": {
            "description": "make a 3x4 matrix representing a uniform scale.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the uniform scale value",
                "name": "scale"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of transformation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3Scale",
            "longname": "makeMatrix3Scale",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix3Translate": {
          "jsdocs": {
            "description": "make a 3x4 matrix representing a translation in 3D",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the x component of the translation",
                "name": "x"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the y component of the translation",
                "name": "y"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the z component of the translation",
                "name": "z"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3x4 matrix"
              }
            ],
            "name": "makeMatrix3Translate",
            "longname": "makeMatrix3Translate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4ReflectZ": {
          "jsdocs": {
            "description": "make a 4x4 representing a reflection across a line in the XY plane\nThis is a 2D operation, assumes everything is in the XY plane.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector specifying the reflection axis",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0]",
                "description": "2D origin specifying a point of reflection",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4ReflectZ",
            "longname": "makeMatrix4ReflectZ",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4Rotate": {
          "jsdocs": {
            "description": "make a 4x4 matrix representing a rotation in 3D\naround a given vector and around a given center of rotation.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,1]",
                "description": "the axis of rotation",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4Rotate",
            "longname": "makeMatrix4Rotate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4RotateX": {
          "jsdocs": {
            "description": "make a 4x4 matrix representing a rotation in 3D around the x-axis\n(allowing you to specify the center of rotation if needed).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4RotateX",
            "longname": "makeMatrix4RotateX",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4RotateY": {
          "jsdocs": {
            "description": "make a 4x4 matrix representing a rotation in 3D around the y-axis\n(allowing you to specify the center of rotation if needed).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4RotateY",
            "longname": "makeMatrix4RotateY",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4RotateZ": {
          "jsdocs": {
            "description": "make a 4x4 matrix representing a rotation in 3D around the z-axis\n(allowing you to specify the center of rotation if needed).",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "angle"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of rotation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4RotateZ",
            "longname": "makeMatrix4RotateZ",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4Scale": {
          "jsdocs": {
            "description": "make a 4x4 matrix representing a uniform scale.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the uniform scale value",
                "name": "scale"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "optional": true,
                "defaultvalue": "[0,0,0]",
                "description": "the center of transformation",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4Scale",
            "longname": "makeMatrix4Scale",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeMatrix4Translate": {
          "jsdocs": {
            "description": "make a 4x4 matrix representing a translation in 3D",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the x component of the translation",
                "name": "x"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the y component of the translation",
                "name": "y"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 0,
                "description": "the z component of the translation",
                "name": "z"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 4x4 matrix"
              }
            ],
            "name": "makeMatrix4Translate",
            "longname": "makeMatrix4Translate",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeOrthographicMatrix4": {
          "jsdocs": {
            "name": "makeOrthographicMatrix4",
            "longname": "makeOrthographicMatrix4",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makePerspectiveMatrix4": {
          "jsdocs": {
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "field of view in radians",
                "name": "FOV"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "aspect ratio",
                "name": "aspect"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "z-near",
                "name": "near"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "z-far",
                "name": "far"
              }
            ],
            "name": "makePerspectiveMatrix4",
            "longname": "makePerspectiveMatrix4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonCircumradius": {
          "jsdocs": {
            "description": "Make a regular polygon from a circumradius,\nthe first point is +X aligned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of sides in the polygon",
                "name": "sides",
                "defaultvalue": 3
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the polygon's circumradius",
                "name": "circumradius"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point as an arrays of numbers"
              }
            ],
            "name": "makePolygonCircumradius",
            "longname": "makePolygonCircumradius",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonCircumradiusSide": {
          "jsdocs": {
            "description": "Make a regular polygon from a circumradius,\nthe middle of the first side is +X aligned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of sides in the polygon",
                "name": "sides",
                "defaultvalue": 3
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the polygon's circumradius",
                "name": "circumradius"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point as an arrays of numbers"
              }
            ],
            "name": "makePolygonCircumradiusSide",
            "longname": "makePolygonCircumradiusSide",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonInradius": {
          "jsdocs": {
            "description": "Make a regular polygon from a inradius,\nthe first point is +X aligned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of sides in the polygon",
                "name": "sides",
                "defaultvalue": 3
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the polygon's inradius",
                "name": "inradius"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point as an arrays of numbers"
              }
            ],
            "name": "makePolygonInradius",
            "longname": "makePolygonInradius",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonInradiusSide": {
          "jsdocs": {
            "description": "Make a regular polygon from a inradius,\nthe middle of the first side is +X aligned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of sides in the polygon",
                "name": "sides",
                "defaultvalue": 3
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the polygon's inradius",
                "name": "inradius"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point as an arrays of numbers"
              }
            ],
            "name": "makePolygonInradiusSide",
            "longname": "makePolygonInradiusSide",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonNonCollinear": {
          "jsdocs": {
            "description": "Remove any collinear vertices from a n-dimensional polygon.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a polygon as an array of ordered points in array form",
                "name": "polygon"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "a copy of the polygon with collinear points removed"
              }
            ],
            "name": "makePolygonNonCollinear",
            "longname": "makePolygonNonCollinear",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonSideLength": {
          "jsdocs": {
            "description": "Make a regular polygon from a side length,\nthe first point is +X aligned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of sides in the polygon",
                "name": "sides",
                "defaultvalue": 3
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the polygon's side length",
                "name": "length"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point as an arrays of numbers"
              }
            ],
            "name": "makePolygonSideLength",
            "longname": "makePolygonSideLength",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makePolygonSideLengthSide": {
          "jsdocs": {
            "description": "Make a regular polygon from a side length,\nthe middle of the first side is +X aligned.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the number of sides in the polygon",
                "name": "sides",
                "defaultvalue": 3
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the polygon's side length",
                "name": "length"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point as an arrays of numbers"
              }
            ],
            "name": "makePolygonSideLengthSide",
            "longname": "makePolygonSideLengthSide",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "matrix4FromQuaternion": {
          "jsdocs": {
            "description": "Create a 4x4 matrix from a quaternion",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a quaternion",
                "name": "quaternion"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 4x4 matrix (array of 16 numbers)"
              }
            ],
            "name": "matrix4FromQuaternion",
            "longname": "matrix4FromQuaternion",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "midpoint": {
          "jsdocs": {
            "description": "compute the midpoint of two vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one vector, dimension matching first parameter"
              }
            ],
            "name": "midpoint",
            "longname": "midpoint",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "midpoint2": {
          "jsdocs": {
            "description": "compute the midpoint of two 2D vectors.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "midpoint2",
            "longname": "midpoint2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "minimum2DPointIndex": {
          "jsdocs": {
            "description": "Get the index of the point in an array considered the absolute minimum.\nFirst check the X values, and in the case of multiple minimums, check the Y values.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points",
                "name": "points"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the index of the point in the array with the smallest component values"
              }
            ],
            "name": "minimum2DPointIndex",
            "longname": "minimum2DPointIndex",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrices2": {
          "jsdocs": {
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "matrix, left/right order matches what you'd see on a page.",
                "name": "matrix,"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "matrix"
              }
            ],
            "name": "multiplyMatrices2",
            "longname": "multiplyMatrices2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrices3": {
          "jsdocs": {
            "description": "multiply two 3x4 matrices together",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the first matrix",
                "name": "matrix"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the second matrix",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix, the product of the two"
              }
            ],
            "name": "multiplyMatrices3",
            "longname": "multiplyMatrices3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrices4": {
          "jsdocs": {
            "description": "multiply two 4x4 matrices together",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the first matrix",
                "name": "matrix"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the second matrix",
                "name": "matrix"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix, the product of the two"
              }
            ],
            "name": "multiplyMatrices4",
            "longname": "multiplyMatrices4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrix2Line2": {
          "jsdocs": {
            "params": [
              {
                "description": "in point-vector form, matrix",
                "name": "line"
              }
            ],
            "returns": [
              {
                "description": "transformed line in point-vector form"
              }
            ],
            "name": "multiplyMatrix2Line2",
            "longname": "multiplyMatrix2Line2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrix2Vector2": {
          "jsdocs": {
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "in array form",
                "name": "vector,"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "in array form",
                "name": "matrix,"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "vector, the input vector transformed by the matrix"
              }
            ],
            "name": "multiplyMatrix2Vector2",
            "longname": "multiplyMatrix2Vector2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrix3Line3": {
          "jsdocs": {
            "description": "multiply one 3D line by a 3x4 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector of the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin of the line",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "transformed line in point-vector form"
              }
            ],
            "name": "multiplyMatrix3Line3",
            "longname": "multiplyMatrix3Line3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrix3Vector3": {
          "jsdocs": {
            "description": "multiply one 3D vector by a 3x4 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "in array form",
                "name": "vector"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the transformed vector"
              }
            ],
            "name": "multiplyMatrix3Vector3",
            "longname": "multiplyMatrix3Vector3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrix4Line3": {
          "jsdocs": {
            "description": "multiply one 3D line by a 4x4 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector of the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin of the line",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "transformed line in point-vector form"
              }
            ],
            "name": "multiplyMatrix4Line3",
            "longname": "multiplyMatrix4Line3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "multiplyMatrix4Vector3": {
          "jsdocs": {
            "description": "multiply one 3D vector by a 4x4 matrix",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one matrix in array form",
                "name": "matrix"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "in array form",
                "name": "vector"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the transformed vector"
              }
            ],
            "name": "multiplyMatrix4Vector3",
            "longname": "multiplyMatrix4Vector3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestPoint": {
          "jsdocs": {
            "description": "find the one point in an array of points closest to a point.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to test nearness to",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points to test against",
                "name": "array_of_points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one point from the array of points"
              }
            ],
            "name": "nearestPoint",
            "longname": "nearestPoint",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestPoint2": {
          "jsdocs": {
            "description": "find the one point in an array of 2D points closest to a 2D point.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the 2D point to test nearness to",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of 2D points to test against",
                "name": "array_of_points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one point from the array of points"
              }
            ],
            "name": "nearestPoint2",
            "longname": "nearestPoint2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestPointOnCircle": {
          "jsdocs": {
            "description": "find the nearest point on the boundary of a circle to another point\nthat is closest to the provided point.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the radius of the circle",
                "name": "radius"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin of the circle as an array of numbers.",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to test nearness to",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a point"
              }
            ],
            "name": "nearestPointOnCircle",
            "longname": "nearestPointOnCircle",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestPointOnLine": {
          "jsdocs": {
            "description": "find the nearest point on a line, ray, or segment.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector of the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a point that the line passes through",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to test nearness to",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "description": "a clamp function to bound a calculation between 0 and 1\nfor segments, greater than 0 for rays, or unbounded for lines.",
                "name": "limiterFunc"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a point"
              }
            ],
            "name": "nearestPointOnLine",
            "longname": "nearestPointOnLine",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "nearestPointOnPolygon": {
          "jsdocs": {
            "description": "given a polygon and a point, in 2D, find a point on the boundary of the polygon\nthat is closest to the provided point.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points (which are arrays of numbers)",
                "name": "polygon"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the point to test nearness to",
                "name": "point"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a point"
              }
            ],
            "name": "nearestPointOnPolygon",
            "longname": "nearestPointOnPolygon",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalize": {
          "jsdocs": {
            "description": "normalize the input vector and return a new vector as a copy",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, dimension matching the input vector"
              }
            ],
            "name": "normalize",
            "longname": "normalize",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalize2": {
          "jsdocs": {
            "description": "normalize the input vector and return a new vector as a copy",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "normalize2",
            "longname": "normalize2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "normalize3": {
          "jsdocs": {
            "description": "normalize the input vector and return a new vector as a copy",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector"
              }
            ],
            "name": "normalize3",
            "longname": "normalize3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "overlapBoundingBoxes": {
          "jsdocs": {
            "description": "Test if two axis-aligned bounding boxes overlap each other.",
            "params": [
              {
                "type": {
                  "names": [
                    "BoundingBox"
                  ]
                },
                "description": "an axis-aligned bounding box, the result of calling boundingBox(...)",
                "name": "box1"
              },
              {
                "type": {
                  "names": [
                    "BoundingBox"
                  ]
                },
                "description": "an axis-aligned bounding box, the result of calling boundingBox(...)",
                "name": "box2"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "true if the bounding boxes overlap each other"
              }
            ],
            "name": "overlapBoundingBoxes",
            "longname": "overlapBoundingBoxes",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "overlapConvexPolygonPoint": {
          "jsdocs": {
            "description": "tests if a point is inside a convex polygon",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "in array form",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "in array of array form",
                "name": "polygon"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "description": "for positive numbers, in/exclude near zero",
                "name": "true"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "is the point inside the polygon?"
              }
            ],
            "name": "overlapConvexPolygonPoint",
            "longname": "overlapConvexPolygonPoint",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "overlapConvexPolygons": {
          "jsdocs": {
            "description": "find out if two convex polygons are overlapping by searching\nfor a dividing axis, which should be one side from one of the polygons.",
            "name": "overlapConvexPolygons",
            "longname": "overlapConvexPolygons",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "overlapLineLine": {
          "jsdocs": {
            "description": "2D line intersection function, generalized and works for lines,\nrays, segments.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "of 2 numbers, the first line's vector",
                "name": "array"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "of 2 numbers, the first line's origin",
                "name": "array"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "of 2 numbers, the second line's vector",
                "name": "array"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "of 2 numbers, the second line's origin",
                "name": "array"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "description": "line's boolean test normalized value lies collinear",
                "name": "first"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "description": "line's boolean test normalized value lies collinear",
                "name": "seconde"
              }
            ],
            "name": "overlapLineLine",
            "longname": "overlapLineLine",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "overlapLinePoint": {
          "jsdocs": {
            "description": "check if a point lies collinear along a line, and specify if the\nline is a line/ray/segment and test whether the point lies within endpoint(s).",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector component of the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin component of the line",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D point",
                "name": "point"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon with a default value of 1e-6",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "is the point collinear to the line, and in the case of ray/segment,\ndoes the point lie within the bounds of the ray/segment?"
              }
            ],
            "name": "overlapLinePoint",
            "longname": "overlapLinePoint",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "parallel": {
          "jsdocs": {
            "description": "check if two vectors are parallel to each other within an epsilon",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon with a default value of 1e-6",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "are the two vectors parallel within an epsilon?"
              }
            ],
            "name": "parallel",
            "longname": "parallel",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "parallel2": {
          "jsdocs": {
            "description": "check if two 2D vectors are parallel to each other within an epsilon",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon with a default value of 1e-6",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "boolean"
                  ]
                },
                "description": "are the two vectors parallel within an epsilon?"
              }
            ],
            "name": "parallel2",
            "longname": "parallel2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "pleat": {
          "jsdocs": {
            "description": "Between two lines, make a repeating sequence of\nevenly-spaced lines to simulate a series of pleats.",
            "params": [
              {
                "type": {
                  "names": [
                    "line"
                  ]
                },
                "description": "with two keys/values: { vector: [], origin: [] }",
                "name": "object"
              },
              {
                "type": {
                  "names": [
                    "line"
                  ]
                },
                "description": "with two keys/values: { vector: [], origin: [] }",
                "name": "object"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "number of faces, the number of lines will be n-1.",
                "name": "the"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "line[]"
                  ]
                },
                "description": "an array of lines, objects which contain \"vector\" and \"origin\""
              }
            ],
            "name": "pleat",
            "longname": "pleat",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "quaternionFromTwoVectors": {
          "jsdocs": {
            "description": "Create a quaternion which represents a rotation from\none 3D vector to another.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 3D vector",
                "name": "u"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a 3D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "a quaternion representing a rotation"
              }
            ],
            "name": "quaternionFromTwoVectors",
            "longname": "quaternionFromTwoVectors",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "radialSortPointIndices": {
          "jsdocs": {
            "description": "radially sort point indices around the lowest-value point, clustering\nsimilarly-angled points within an epsilon. Within these clusters, the points are\nsorted by distance so the nearest point is listed first.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points",
                "name": "points"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "this returns indices in clusters."
              }
            ],
            "name": "radialSortPointIndices",
            "longname": "radialSortPointIndices",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "rayLimiter": {
          "jsdocs": {
            "description": "These clamp functions process lines/rays/segments intersections.\nThe ray method clamps values below -epsilon to be 0.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the length along the vector",
                "name": "t"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the clamped input value"
              }
            ],
            "name": "rayLimiter",
            "longname": "rayLimiter",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "rayLineToUniqueLine": {
          "jsdocs": {
            "description": "convert a line from one parameterization into another.\nconvert vector-origin into u-d (normal, distance-to-origin)",
            "name": "rayLineToUniqueLine",
            "longname": "rayLineToUniqueLine",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "resize": {
          "jsdocs": {
            "description": "force a vector into N-dimensions by adding 0s if they don't exist.",
            "name": "resize",
            "longname": "resize",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "resizeDown": {
          "jsdocs": {
            "description": "this makes the two vectors match in dimension.\nthe larger array will be shrunk to match the length of the smaller",
            "name": "resizeDown",
            "longname": "resizeDown",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "resizeUp": {
          "jsdocs": {
            "description": "this makes the two vectors match in dimension.\nthe smaller array will be filled with 0s to match the length of the larger",
            "name": "resizeUp",
            "longname": "resizeUp",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "rotate270": {
          "jsdocs": {
            "description": "return a copy of the input vector rotated 270 degrees counter-clockwise",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "rotate270",
            "longname": "rotate270",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "rotate90": {
          "jsdocs": {
            "description": "return a copy of the input vector rotated 90 degrees counter-clockwise",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "rotate90",
            "longname": "rotate90",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "scale": {
          "jsdocs": {
            "description": "scale an input vector by one number, return a copy.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar",
                "name": "s"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector"
              }
            ],
            "name": "scale",
            "longname": "scale",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "scale2": {
          "jsdocs": {
            "description": "scale an input vector by one number, return a copy.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "one scalar",
                "name": "s"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "scale2",
            "longname": "scale2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "segmentLimiter": {
          "jsdocs": {
            "description": "These clamp functions process lines/rays/segments intersections.\nThe segment method clamps values below -epsilon to be 0 and above 1+epsilon to 1.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the length along the vector",
                "name": "t"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the clamped input value"
              }
            ],
            "name": "segmentLimiter",
            "longname": "segmentLimiter",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "semiFlattenArrays": {
          "jsdocs": {
            "description": "flatten only until the point of comma separated entities. recursive",
            "params": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "any array, intended to contain arrays of arrays.",
                "name": "args"
              }
            ],
            "returns": [
              {
                "description": "always an array"
              }
            ],
            "name": "semiFlattenArrays",
            "longname": "semiFlattenArrays",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "signedArea": {
          "jsdocs": {
            "description": "Calculates the signed area of a polygon.\nThis requires the polygon be non-self-intersecting.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of 2D points, which are arrays of numbers",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the area of the polygon"
              }
            ],
            "examples": [
              "var area = polygon.signedArea([ [1,2], [5,6], [7,0] ])"
            ],
            "name": "signedArea",
            "longname": "signedArea",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "smallestComparisonSearch": {
          "jsdocs": {
            "description": "find the one item in the set which minimizes the\nfunction when compared against all other objects in the array.\nFor example, find the nearest point from an array to a reference.",
            "params": [
              {
                "type": {
                  "names": [
                    "any"
                  ]
                },
                "description": "the single item to test against the set",
                "name": "obj"
              },
              {
                "type": {
                  "names": [
                    "any[]"
                  ]
                },
                "description": "the set of items to test against",
                "name": "array"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "description": "a function which takes two items (which match\nthe type of the first parameter), execution of this function should return a scalar.",
                "name": "compare_func"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the index from the set which minimizes the compare function"
              }
            ],
            "name": "smallestComparisonSearch",
            "longname": "smallestComparisonSearch",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "sortPointsAlongVector2": {
          "jsdocs": {
            "description": "sort an array of 2D points along a 2D vector.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of points (which are arrays of numbers)",
                "name": "points"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "vector"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "the same points, sorted."
              }
            ],
            "name": "sortPointsAlongVector2",
            "longname": "sortPointsAlongVector2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "splitConvexPolygon": {
          "jsdocs": {
            "description": "Split a convex polygon by a line and rebuild each half into two convex polygons.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "an array of points, each point is an array of numbers",
                "name": "polygon"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the vector component of the line",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the origin component of the line",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][][]"
                  ]
                },
                "description": "an array of one or two polygons, each polygon is an array of points,\neach point is an array of numbers."
              }
            ],
            "name": "splitConvexPolygon",
            "longname": "splitConvexPolygon",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "straightSkeleton": {
          "jsdocs": {
            "description": "create a straight skeleton inside of a convex polygon",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "counter-clockwise polygon as an array of points\n(which are arrays of numbers)",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "object[]"
                  ]
                },
                "description": "list of objects containing \"points\" {number[][]}: two points\ndefining a line segment, and \"type\" {string}: either \"skeleton\" or \"perpendicular\"\n\nmake sure:\n - your polygon is convex (todo: make this algorithm work with non-convex)\n - your polygon points are sorted counter-clockwise"
              }
            ],
            "name": "straightSkeleton",
            "longname": "straightSkeleton",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "subtract": {
          "jsdocs": {
            "description": "subtract the second vector from the first, return the result as a copy.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, n-dimensions",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one vector, dimension matching first parameter"
              }
            ],
            "name": "subtract",
            "longname": "subtract",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "subtract2": {
          "jsdocs": {
            "description": "subtract the second vector from the first, return the result as a copy.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 2D vector"
              }
            ],
            "name": "subtract2",
            "longname": "subtract2",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "subtract3": {
          "jsdocs": {
            "description": "subtract the second vector from the first, return the result as a copy.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "v"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector",
                "name": "u"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one 3D vector"
              }
            ],
            "name": "subtract3",
            "longname": "subtract3",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "threePointTurnDirection": {
          "jsdocs": {
            "description": "which turn direction do 3 points make? clockwise or couter-clockwise",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the start point",
                "name": "p0"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the middle point",
                "name": "p1"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the end point",
                "name": "p2"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number",
                    "undefined"
                  ]
                },
                "description": "with 4 possible results:\n- \"0\": collinear, no turn, forward\n- \"1\": counter-clockwise turn, 0+epsilon < x < 180-epsilon\n- \"-1\": clockwise turn, 0-epsilon > x > -180+epsilon\n- \"undefined\": collinear but with a 180 degree turn."
              }
            ],
            "name": "threePointTurnDirection",
            "longname": "threePointTurnDirection",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "uniqueLineToRayLine": {
          "jsdocs": {
            "description": "convert a line from one parameterization into another.\nconvert u-d (normal, distance-to-origin) into vector-origin",
            "name": "uniqueLineToRayLine",
            "longname": "uniqueLineToRayLine",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        }
      },
      "type": "undefined"
    },
    "matrix": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a 3x4 column-major matrix containing three basis\nvectors and a translation column. This comes with object methods and\nthis is the one primitive in the library which **is mutable**.",
        "params": [
          {
            "type": {
              "names": [
                "number[]",
                "number"
              ]
            },
            "description": "one array of 12 numbers, or 12 numbers listed as parameters.",
            "name": "numbers"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "matrix"
              ]
            },
            "description": "one 3x4 matrix object"
          }
        ],
        "name": "matrix",
        "longname": "ear.matrix",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "origami": {
      "jsdocs": {
        "name": "Origami",
        "description": "A model of an origami paper. Empty parameter initialization will\ncreate a single-face graph with a unit square boundary.",
        "params": [
          {
            "type": {
              "names": [
                "FOLD"
              ]
            },
            "optional": true,
            "description": "an optional FOLD object",
            "name": "graph"
          }
        ],
        "longname": "Origami",
        "kind": "member",
        "scope": "global"
      },
      "children": {
        "kite": {
          "jsdocs": {
            "description": "Create a kite base FOLD object, in crease pattern form.",
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "kite",
            "longname": "Create.kite",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "polygon": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a polygon defined by a sequence of points. This comes with\nobject methods and can be used in intersection calculations. The polygon can be non-convex,\nbut some methods only work on convex polygons.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "...Array.<number>"
                  ]
                },
                "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "polygon"
                  ]
                },
                "description": "one polygon object"
              }
            ],
            "name": "polygon",
            "longname": "ear.polygon",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "rectangle": {
          "jsdocs": {
            "description": "Create a new FOLD object which contains one rectangular face,\nincluding vertices and boundary edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the width of the rectangle",
                "name": "width"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the height of the rectangle",
                "name": "height"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "rectangle",
            "longname": "Create.rectangle",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        },
        "square": {
          "jsdocs": {
            "description": "Create a new FOLD object which contains one square face,\nincluding vertices and boundary edges.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": 1,
                "description": "the length of the sides.",
                "name": "scale"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object"
              }
            ],
            "name": "square",
            "longname": "Create.square",
            "kind": "function",
            "memberof": "Create",
            "scope": "static"
          },
          "type": "Function"
        }
      },
      "type": "Function"
    },
    "overlap": {
      "jsdocs": {
        "name": "overlap",
        "description": "test whether or not two geometry objects overlap each other.",
        "params": [
          {
            "type": {
              "names": [
                "any"
              ]
            },
            "description": "any geometry object",
            "name": "a"
          },
          {
            "type": {
              "names": [
                "any"
              ]
            },
            "description": "any geometry object",
            "name": "b"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "optional": true,
            "defaultvalue": "1e-6",
            "description": "optional epsilon",
            "name": "epsilon"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "boolean"
              ]
            },
            "description": "true if the two objects overlap."
          }
        ],
        "longname": "overlap",
        "kind": "member",
        "scope": "global"
      },
      "type": "Function"
    },
    "polygon": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a polygon defined by a sequence of points. This comes with\nobject methods and can be used in intersection calculations. The polygon can be non-convex,\nbut some methods only work on convex polygons.",
        "params": [
          {
            "type": {
              "names": [
                "number[][]",
                "...Array.<number>"
              ]
            },
            "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
            "name": "points"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "polygon"
              ]
            },
            "description": "one polygon object"
          }
        ],
        "name": "polygon",
        "longname": "ear.polygon",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "polyline": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a polyline defined by a sequence of points.",
        "params": [
          {
            "type": {
              "names": [
                "number[][]",
                "...Array.<number>"
              ]
            },
            "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
            "name": "points"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "polyline"
              ]
            },
            "description": "one polyline object"
          }
        ],
        "name": "polyline",
        "longname": "ear.polyline",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "ray": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a ray defined by a vector and an origin point.\nThis object comes with object methods and can be used in intersection calculations.",
        "params": [
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the ray's vector",
            "name": "vector"
          },
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the ray's origin (without this, it will assumed to be the origin)",
            "name": "origin"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "ray"
              ]
            },
            "description": "one ray object"
          }
        ],
        "name": "ray",
        "longname": "ear.ray",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "rect": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make an 2D axis-aligned rectangle defined by a corner point\nand a width and height. This comes with object methods and can\nbe used in intersection calculations.",
        "params": [
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the x coordinate of the origin",
            "name": "x"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the y coordinate of the origin",
            "name": "y"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the width of the rectangle",
            "name": "width"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "description": "the height of the rectangle",
            "name": "height"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "rect"
              ]
            },
            "description": "one rect object"
          }
        ],
        "name": "rect",
        "longname": "ear.rect",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "segment": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a segment defined by two endpoints. This object comes\nwith object methods and can be used in intersection calculations.",
        "params": [
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the first point",
            "name": "a"
          },
          {
            "type": {
              "names": [
                "number[]"
              ]
            },
            "description": "the second point",
            "name": "b"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "segment"
              ]
            },
            "description": "one segment object"
          }
        ],
        "name": "segment",
        "longname": "ear.segment",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "singleVertex": {
      "jsdocs": {
        "description": "A collection of operations done on single vertices\n(one vertex in a graph typically surrounded by edges).",
        "name": "singleVertex",
        "longname": "singleVertex",
        "kind": "member",
        "scope": "global",
        "params": []
      },
      "children": {
        "alternatingSum": {
          "jsdocs": {
            "description": "given a list of numbers this method will sort them by\n even and odd indices and sum the two categories, returning two sums.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one list of numbers",
                "name": "numbers"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one array of two sums, even and odd indices"
              }
            ],
            "name": "alternatingSum",
            "longname": "alternatingSum",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "alternatingSumDifference": {
          "jsdocs": {
            "description": "alternatingSum, filter odd and even into two categories, then\n then set them to be the deviation from the average of the sum.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one list of numbers",
                "name": "sectors"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "one array of two numbers. if both alternating sets sum\n to the same, the result will be [0, 0]. if the first set is 2 more than the\n second, the result will be [1, -1]. (not [2, 0] or something with a 2 in it)"
              }
            ],
            "name": "alternatingSumDifference",
            "longname": "alternatingSumDifference",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "foldAngles4": {
          "jsdocs": {
            "description": "fold a degree-4 single vertex in 3D.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "an array of sector angles, sorted, around the single vertex.",
                "name": "sectors"
              },
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "an array of FOLD spec characters, \"M\" or \"V\".",
                "name": "assignments"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the fold amount between 0 and 1.",
                "name": "t",
                "defaultvalue": 0
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "four fold angles as numbers in an array."
              }
            ],
            "name": "foldAngles4",
            "longname": "foldAngles4",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "kawasakiSolutions": {
          "jsdocs": {
            "description": "given a single vertex in a graph which does not yet satisfy Kawasaki's theorem,\nfind all possible single-ray additions which when added to the set, the set\nsatisfies Kawasaki's theorem.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the index of the vertex",
                "name": "vertex"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "for every sector either one vector or\nundefined if that sector contains no solution."
              }
            ],
            "name": "kawasakiSolutions",
            "longname": "kawasakiSolutions",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "kawasakiSolutionsRadians": {
          "jsdocs": {
            "description": "given a set of edges around a single vertex (expressed as an array\nof radian angles), find all possible single-ray additions which\nwhen added to the set, the set satisfies Kawasaki's theorem.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the angle of the edges in radians,\nlike vectors around a vertex. pre-sorted.",
                "name": "radians"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "for every sector either one vector (as an angle in radians)\nor undefined if that sector contains no solution."
              }
            ],
            "name": "kawasakiSolutionsRadians",
            "longname": "kawasakiSolutionsRadians",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "kawasakiSolutionsVectors": {
          "jsdocs": {
            "description": "given a set of edges around a single vertex (expressed as an array\nof vectors), find all possible single-ray additions which\nwhen added to the set, the set satisfies Kawasaki's theorem.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "array of vectors, the edges around a single vertex. pre-sorted.",
                "name": "vectors"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[][]"
                  ]
                },
                "description": "for every sector either one vector\nor undefined if that sector contains no solution."
              }
            ],
            "name": "kawasakiSolutionsVectors",
            "longname": "kawasakiSolutionsVectors",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "maekawaAssignments": {
          "jsdocs": {
            "description": "given a set of assignments (M/V/F/B/U characters), which contains\nsome U (unassigned), find all permutations of mountain valley to replace all U.\nThis function solves only one single vertex, the assignments are sorted radially\naround the vertex. This validates according to Maekawa's theorem only.",
            "params": [
              {
                "type": {
                  "names": [
                    "string[]"
                  ]
                },
                "description": "array of single character\nFOLD spec edges assignments.",
                "name": "vertices_edges_assignments"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "string[][]"
                  ]
                },
                "description": "array of arrays of strings, all permutations where \"U\"\nassignments have been replaced with \"V\" or \"M\"."
              }
            ],
            "name": "maekawaAssignments",
            "longname": "maekawaAssignments",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateKawasaki": {
          "jsdocs": {
            "description": "using the vertices of the edges, check if Kawasaki's theorem is satisfied\nfor all vertices, and if not, return the vertices which violate the theorem.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "defaultvalue": "1e-6",
                "description": "an optional epsilon",
                "name": "epsilon"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "indices of vertices which violate the theorem. an empty array has no errors."
              }
            ],
            "name": "validateKawasaki",
            "longname": "validateKawasaki",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "validateMaekawa": {
          "jsdocs": {
            "description": "using edges_assignment, check if Maekawa's theorem is satisfied\nfor all vertices, and if not, return the vertices which violate the theorem.\ntodo: this assumes that valley/mountain folds are flat folded.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD object",
                "name": "graph"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "indices of vertices which violate the theorem. an empty array has no errors."
              }
            ],
            "name": "validateMaekawa",
            "longname": "validateMaekawa",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        }
      },
      "type": "undefined"
    },
    "svg": {
      "jsdocs": {
        "name": "svg",
        "description": "Create an svg element, the object will be bound with instance\nmethods for creating children and styles.",
        "memberof": "svg",
        "params": [
          {
            "type": {
              "names": [
                "Element"
              ]
            },
            "optional": true,
            "description": "optional parent DOM element, this will append to.",
            "name": "parent"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "optional": true,
            "description": "optional width of viewBox (if present, include height)",
            "name": "width"
          },
          {
            "type": {
              "names": [
                "number"
              ]
            },
            "optional": true,
            "description": "optional height of viewBox (if present, include width)",
            "name": "height"
          },
          {
            "type": {
              "names": [
                "function"
              ]
            },
            "optional": true,
            "description": "optional function which will be\nexecuted upon completion of initialization.",
            "name": "callback"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Element"
              ]
            },
            "description": "one svg DOM element"
          }
        ],
        "examples": [
          "var svg = ear.svg(document.body, 640, 480)",
          "ear.svg(640, 480, document.body, (svg) => {\n  // window did load, and \"svg\" is scoped\n})"
        ],
        "scope": "static",
        "longname": "svg.svg",
        "kind": "member"
      },
      "children": {
        "NS": {
          "jsdocs": {
            "description": "The namespace of an SVG element, the value of the attribute xmlns",
            "name": "NS",
            "longname": "NS",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "String"
        },
        "arc": {
          "type": "Function"
        },
        "arrow": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "Arrow",
            "longname": "Arrow",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "cdata": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "cdata",
            "longname": "cdata",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "circle": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a circle defined by a radius and a center. This comes with\nobject methods and can be used in intersection calculations.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the circle's radius",
                "name": "radius"
              },
              {
                "type": {
                  "names": [
                    "number[]",
                    "number"
                  ]
                },
                "description": "the center of the circle",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "circle"
                  ]
                },
                "description": "one circle object"
              }
            ],
            "name": "circle",
            "longname": "ear.circle",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "clipPath": {
          "type": "Function"
        },
        "core": {
          "children": {
            "addClass": {
              "type": "Function"
            },
            "appendTo": {
              "type": "Function"
            },
            "attributes": {
              "jsdocs": {
                "description": "SVG (c) Kraft",
                "name": "attributes",
                "longname": "attributes",
                "kind": "member",
                "scope": "global",
                "params": []
              },
              "children": {
                "cdata": {
                  "type": "Array"
                },
                "circle": {
                  "type": "Array"
                },
                "clipPath": {
                  "type": "Array"
                },
                "defs": {
                  "type": "Array"
                },
                "desc": {
                  "type": "Array"
                },
                "ellipse": {
                  "type": "Array"
                },
                "feBlend": {
                  "type": "Array"
                },
                "feColorMatrix": {
                  "type": "Array"
                },
                "feComponentTransfer": {
                  "type": "Array"
                },
                "feComposite": {
                  "type": "Array"
                },
                "feConvolveMatrix": {
                  "type": "Array"
                },
                "feDiffuseLighting": {
                  "type": "Array"
                },
                "feDisplacementMap": {
                  "type": "Array"
                },
                "feDistantLight": {
                  "type": "Array"
                },
                "feDropShadow": {
                  "type": "Array"
                },
                "feFlood": {
                  "type": "Array"
                },
                "feFuncA": {
                  "type": "Array"
                },
                "feFuncB": {
                  "type": "Array"
                },
                "feFuncG": {
                  "type": "Array"
                },
                "feFuncR": {
                  "type": "Array"
                },
                "feGaussianBlur": {
                  "type": "Array"
                },
                "feImage": {
                  "type": "Array"
                },
                "feMerge": {
                  "type": "Array"
                },
                "feMergeNode": {
                  "type": "Array"
                },
                "feMorphology": {
                  "type": "Array"
                },
                "feOffset": {
                  "type": "Array"
                },
                "fePointLight": {
                  "type": "Array"
                },
                "feSpecularLighting": {
                  "type": "Array"
                },
                "feSpotLight": {
                  "type": "Array"
                },
                "feTile": {
                  "type": "Array"
                },
                "feTurbulence": {
                  "type": "Array"
                },
                "filter": {
                  "type": "Array"
                },
                "g": {
                  "type": "Array"
                },
                "line": {
                  "type": "Array"
                },
                "linearGradient": {
                  "type": "Array"
                },
                "marker": {
                  "type": "Array"
                },
                "mask": {
                  "type": "Array"
                },
                "metadata": {
                  "type": "Array"
                },
                "path": {
                  "type": "Array"
                },
                "pattern": {
                  "type": "Array"
                },
                "polygon": {
                  "type": "Array"
                },
                "polyline": {
                  "type": "Array"
                },
                "radialGradient": {
                  "type": "Array"
                },
                "rect": {
                  "type": "Array"
                },
                "script": {
                  "type": "Array"
                },
                "stop": {
                  "type": "Array"
                },
                "style": {
                  "type": "Array"
                },
                "svg": {
                  "type": "Array"
                },
                "symbol": {
                  "type": "Array"
                },
                "text": {
                  "type": "Array"
                },
                "textPath": {
                  "type": "Array"
                },
                "title": {
                  "type": "Array"
                },
                "tspan": {
                  "type": "Array"
                },
                "view": {
                  "type": "Array"
                }
              },
              "type": "undefined"
            },
            "capitalized": {
              "type": "Function"
            },
            "cdata": {
              "jsdocs": {
                "description": "SVG (c) Kraft",
                "name": "cdata",
                "longname": "cdata",
                "kind": "function",
                "scope": "global",
                "params": []
              },
              "type": "Function"
            },
            "children": {
              "children": {
                "clipPath": {
                  "type": "Array"
                },
                "defs": {
                  "type": "Array"
                },
                "filter": {
                  "type": "Array"
                },
                "g": {
                  "type": "Array"
                },
                "linearGradient": {
                  "type": "Array"
                },
                "marker": {
                  "type": "Array"
                },
                "mask": {
                  "type": "Array"
                },
                "origami": {
                  "type": "Array"
                },
                "radialGradient": {
                  "type": "Array"
                },
                "svg": {
                  "type": "Array"
                },
                "symbol": {
                  "type": "Array"
                },
                "text": {
                  "type": "Array"
                }
              },
              "type": "undefined"
            },
            "clearTransform": {
              "type": "Function"
            },
            "convertToViewBox": {
              "type": "Function"
            },
            "coordinates": {
              "jsdocs": {
                "description": "this will extract coordinates from a set of inputs\nand present them as a stride-2 flat array. length % 2 === 0\na 1D array of numbers, alternating x y\n\nuse flatten() everytime you call this!\nit's necessary the entries sit at the top level of ...args\nfindCoordinates(...flatten(...args));",
                "name": "coordinates",
                "longname": "coordinates",
                "kind": "function",
                "scope": "global",
                "params": []
              },
              "type": "Function"
            },
            "flatten": {
              "type": "Function"
            },
            "getViewBox": {
              "type": "Function"
            },
            "load": {
              "type": "Function"
            },
            "matrix": {
              "jsdocs": {
                "memberof": "ear",
                "description": "Make a 3x4 column-major matrix containing three basis\nvectors and a translation column. This comes with object methods and\nthis is the one primitive in the library which **is mutable**.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "number[]",
                        "number"
                      ]
                    },
                    "description": "one array of 12 numbers, or 12 numbers listed as parameters.",
                    "name": "numbers"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "matrix"
                      ]
                    },
                    "description": "one 3x4 matrix object"
                  }
                ],
                "name": "matrix",
                "longname": "ear.matrix",
                "kind": "function",
                "scope": "static"
              },
              "type": "Function"
            },
            "removeChildren": {
              "jsdocs": {
                "description": "SVG (c) Kraft",
                "name": "removeChildren",
                "longname": "removeChildren",
                "kind": "function",
                "scope": "global",
                "params": []
              },
              "type": "Function"
            },
            "removeClass": {
              "type": "Function"
            },
            "rotate": {
              "type": "Function"
            },
            "save": {
              "type": "Function"
            },
            "scale": {
              "jsdocs": {
                "description": "scale an input vector by one number, return a copy.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "number[]"
                      ]
                    },
                    "description": "one vector, n-dimensions",
                    "name": "v"
                  },
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "one scalar",
                    "name": "s"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number[]"
                      ]
                    },
                    "description": "one vector"
                  }
                ],
                "name": "scale",
                "longname": "scale",
                "kind": "function",
                "scope": "global"
              },
              "type": "Function"
            },
            "setAttributes": {
              "type": "Function"
            },
            "setClass": {
              "type": "Function"
            },
            "setId": {
              "type": "Function"
            },
            "setViewBox": {
              "jsdocs": {
                "description": "SVG (c) Kraft",
                "name": "setViewBox",
                "longname": "setViewBox",
                "kind": "function",
                "scope": "global",
                "params": []
              },
              "type": "Function"
            },
            "svg_add2": {
              "jsdocs": {
                "description": "SVG (c) Kraft",
                "name": "svg_add2",
                "longname": "svg_add2",
                "kind": "function",
                "scope": "global",
                "params": []
              },
              "type": "Function"
            },
            "svg_distance2": {
              "type": "Function"
            },
            "svg_distanceSq2": {
              "type": "Function"
            },
            "svg_magnitude2": {
              "type": "Function"
            },
            "svg_magnitudeSq2": {
              "type": "Function"
            },
            "svg_polar_to_cart": {
              "type": "Function"
            },
            "svg_scale2": {
              "type": "Function"
            },
            "svg_sub2": {
              "type": "Function"
            },
            "toCamel": {
              "type": "Function"
            },
            "toKebab": {
              "type": "Function"
            },
            "translate": {
              "jsdocs": {
                "name": "translate",
                "memberof": "graph",
                "description": "apply a translation to a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  },
                  {
                    "type": {
                      "names": [
                        "number[]"
                      ]
                    },
                    "description": "an array or series of numbers, the translation vector",
                    "name": "optional."
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "the same input graph, modified"
                  }
                ],
                "scope": "static",
                "longname": "graph.translate",
                "kind": "member"
              },
              "type": "Function"
            }
          },
          "type": "undefined"
        },
        "curve": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "Curve",
            "longname": "Curve",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "defs": {
          "type": "Function"
        },
        "desc": {
          "type": "Function"
        },
        "ellipse": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make an ellipse defined by a two radii and a center. This comes with object methods.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the radius along the x axis",
                "name": "rx"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the radius along the y axis",
                "name": "ry"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the center of the ellipse",
                "name": "origin"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the angle of rotation in radians",
                "name": "spin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "ellipse"
                  ]
                },
                "description": "one ellipse object"
              }
            ],
            "name": "ellipse",
            "longname": "ear.ellipse",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "feBlend": {
          "type": "Function"
        },
        "feColorMatrix": {
          "type": "Function"
        },
        "feComponentTransfer": {
          "type": "Function"
        },
        "feComposite": {
          "type": "Function"
        },
        "feConvolveMatrix": {
          "type": "Function"
        },
        "feDiffuseLighting": {
          "type": "Function"
        },
        "feDisplacementMap": {
          "type": "Function"
        },
        "feDistantLight": {
          "type": "Function"
        },
        "feDropShadow": {
          "type": "Function"
        },
        "feFlood": {
          "type": "Function"
        },
        "feFuncA": {
          "type": "Function"
        },
        "feFuncB": {
          "type": "Function"
        },
        "feFuncG": {
          "type": "Function"
        },
        "feFuncR": {
          "type": "Function"
        },
        "feGaussianBlur": {
          "type": "Function"
        },
        "feImage": {
          "type": "Function"
        },
        "feMerge": {
          "type": "Function"
        },
        "feMergeNode": {
          "type": "Function"
        },
        "feMorphology": {
          "type": "Function"
        },
        "feOffset": {
          "type": "Function"
        },
        "fePointLight": {
          "type": "Function"
        },
        "feSpecularLighting": {
          "type": "Function"
        },
        "feSpotLight": {
          "type": "Function"
        },
        "feTile": {
          "type": "Function"
        },
        "feTurbulence": {
          "type": "Function"
        },
        "filter": {
          "type": "Function"
        },
        "g": {
          "type": "Function"
        },
        "line": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a line defined by a vector and a point passing through the line.\nThis object comes with object methods and can be used in intersection calculations.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the line's vector",
                "name": "vector"
              },
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "the line's origin (without this, it will assumed to be the origin)",
                "name": "origin"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "line"
                  ]
                },
                "description": "one line object"
              }
            ],
            "name": "line",
            "longname": "ear.line",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "linearGradient": {
          "type": "Function"
        },
        "linker": {
          "jsdocs": {
            "description": "link this library to the larger RabbitEar library. this allows\nRabbit Ear to be built with or without this extension.",
            "name": "linker",
            "longname": "linker",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "marker": {
          "type": "Function"
        },
        "mask": {
          "type": "Function"
        },
        "metadata": {
          "type": "Function"
        },
        "origami": {
          "jsdocs": {
            "name": "Origami",
            "description": "A model of an origami paper. Empty parameter initialization will\ncreate a single-face graph with a unit square boundary.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "optional": true,
                "description": "an optional FOLD object",
                "name": "graph"
              }
            ],
            "longname": "Origami",
            "kind": "member",
            "scope": "global"
          },
          "children": {
            "boundaries": {
              "type": "Function"
            },
            "drawInto": {
              "jsdocs": {
                "name": "drawInto",
                "memberof": "graph",
                "description": "renders a FOLD object into an SVG, ensuring visibility by\nsetting the viewBox and the stroke-width attributes on the SVG.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "SVGElement"
                      ]
                    },
                    "description": "an already initialized SVG DOM element.",
                    "name": "element"
                  },
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD object",
                    "name": "graph"
                  },
                  {
                    "type": {
                      "names": [
                        "object"
                      ]
                    },
                    "description": "an optional options object to style the rendering",
                    "name": "options"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "SVGElement"
                      ]
                    },
                    "description": "the first SVG parameter object."
                  }
                ],
                "scope": "static",
                "longname": "graph.drawInto",
                "kind": "member"
              },
              "type": "Function"
            },
            "edges": {
              "jsdocs": {
                "description": "Get the number of edges in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of edges in the graph"
                  }
                ],
                "name": "edges",
                "longname": "count.edges",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "faces": {
              "jsdocs": {
                "description": "Get the number of faces in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of faces in the graph"
                  }
                ],
                "name": "faces",
                "longname": "count.faces",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            },
            "getViewBox": {
              "type": "Function"
            },
            "vertices": {
              "jsdocs": {
                "description": "Get the number of vertices in a graph.",
                "params": [
                  {
                    "type": {
                      "names": [
                        "FOLD"
                      ]
                    },
                    "description": "a FOLD graph",
                    "name": "graph"
                  }
                ],
                "returns": [
                  {
                    "type": {
                      "names": [
                        "number"
                      ]
                    },
                    "description": "the number of vertices in the graph"
                  }
                ],
                "name": "vertices",
                "longname": "count.vertices",
                "kind": "function",
                "memberof": "count",
                "scope": "static"
              },
              "type": "Function"
            }
          },
          "type": "Function"
        },
        "parabola": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "Parabola",
            "longname": "Parabola",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "path": {
          "type": "Function"
        },
        "pattern": {
          "type": "Function"
        },
        "polygon": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a polygon defined by a sequence of points. This comes with\nobject methods and can be used in intersection calculations. The polygon can be non-convex,\nbut some methods only work on convex polygons.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "...Array.<number>"
                  ]
                },
                "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "polygon"
                  ]
                },
                "description": "one polygon object"
              }
            ],
            "name": "polygon",
            "longname": "ear.polygon",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "polyline": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make a polyline defined by a sequence of points.",
            "params": [
              {
                "type": {
                  "names": [
                    "number[][]",
                    "...Array.<number>"
                  ]
                },
                "description": "one array containing points (array of numbers)\nor a list of points as the arguments.",
                "name": "points"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "polyline"
                  ]
                },
                "description": "one polyline object"
              }
            ],
            "name": "polyline",
            "longname": "ear.polyline",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "radialGradient": {
          "type": "Function"
        },
        "rect": {
          "jsdocs": {
            "memberof": "ear",
            "description": "Make an 2D axis-aligned rectangle defined by a corner point\nand a width and height. This comes with object methods and can\nbe used in intersection calculations.",
            "params": [
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the x coordinate of the origin",
                "name": "x"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the y coordinate of the origin",
                "name": "y"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the width of the rectangle",
                "name": "width"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the height of the rectangle",
                "name": "height"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "rect"
                  ]
                },
                "description": "one rect object"
              }
            ],
            "name": "rect",
            "longname": "ear.rect",
            "kind": "function",
            "scope": "static"
          },
          "type": "Function"
        },
        "regularPolygon": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "RegularPolygon",
            "longname": "RegularPolygon",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "roundRect": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "RoundRect",
            "longname": "RoundRect",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "script": {
          "type": "Function"
        },
        "stop": {
          "type": "Function"
        },
        "style": {
          "type": "Function"
        },
        "svg": {
          "jsdocs": {
            "name": "svg",
            "description": "Create an svg element, the object will be bound with instance\nmethods for creating children and styles.",
            "memberof": "svg",
            "params": [
              {
                "type": {
                  "names": [
                    "Element"
                  ]
                },
                "optional": true,
                "description": "optional parent DOM element, this will append to.",
                "name": "parent"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "description": "optional width of viewBox (if present, include height)",
                "name": "width"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "optional": true,
                "description": "optional height of viewBox (if present, include width)",
                "name": "height"
              },
              {
                "type": {
                  "names": [
                    "function"
                  ]
                },
                "optional": true,
                "description": "optional function which will be\nexecuted upon completion of initialization.",
                "name": "callback"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Element"
                  ]
                },
                "description": "one svg DOM element"
              }
            ],
            "examples": [
              "var svg = ear.svg(document.body, 640, 480)",
              "ear.svg(640, 480, document.body, (svg) => {\n  // window did load, and \"svg\" is scoped\n})"
            ],
            "scope": "static",
            "longname": "svg.svg",
            "kind": "member"
          },
          "type": "Function"
        },
        "symbol": {
          "type": "Function"
        },
        "text": {
          "jsdocs": {
            "description": "A multi-lingual raw-text reference containing a rudimentary\nset of origami operations, the aim being to parameterize origami instructions\nallowing us to be able to easily convert from one language to another.",
            "name": "text",
            "longname": "text",
            "kind": "member",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "textPath": {
          "type": "Function"
        },
        "title": {
          "type": "Function"
        },
        "tspan": {
          "type": "Function"
        },
        "view": {
          "type": "Function"
        },
        "wedge": {
          "type": "Function"
        }
      },
      "type": "Function"
    },
    "typeof": {
      "jsdocs": {
        "description": "get the type of an object, which includes the custom types in this library.",
        "params": [
          {
            "type": {
              "names": [
                "any"
              ]
            },
            "description": "object",
            "name": "any"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "string"
              ]
            },
            "description": "the type name"
          }
        ],
        "name": "typeOf",
        "longname": "typeOf",
        "kind": "function",
        "scope": "global"
      },
      "type": "Function"
    },
    "vector": {
      "jsdocs": {
        "memberof": "ear",
        "description": "Make a vector primitive from a sequence of numbers.\nThis vector/point object comes with object methods, the object is **immutable**\nand methods will return modified copies. The object inherits from Array.prototype\nso that its components can be accessed via array syntax, [0], [1], or .x, .y, .z properties.\nThere is no limit to the dimensions, some methods like cross product are dimension-specific.",
        "params": [
          {
            "type": {
              "names": [
                "number",
                "number[]"
              ]
            },
            "description": "a list of numbers as arguments or inside an array",
            "name": "numbers"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "vector"
              ]
            },
            "description": "one vector object"
          }
        ],
        "name": "vector",
        "longname": "ear.vector",
        "kind": "function",
        "scope": "static"
      },
      "type": "Function"
    },
    "webgl": {
      "jsdocs": {
        "description": "WebGL methods",
        "name": "webgl",
        "longname": "webgl",
        "kind": "member",
        "scope": "global",
        "params": []
      },
      "children": {
        "cpEdgesV1": {
          "type": "Function"
        },
        "cpEdgesV2": {
          "type": "Function"
        },
        "cpFacesV1": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "cpFacesV1",
            "longname": "cpFacesV1",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "cpFacesV2": {
          "type": "Function"
        },
        "creasePattern": {
          "jsdocs": {
            "description": "Crease Pattern - a flat-array, index-based graph with faces, edges, and vertices\nthat exist in 2D space, edges resolved so there are no edge crossings.\nThe naming scheme for keys follows the FOLD format.",
            "name": "CreasePattern",
            "longname": "CreasePattern",
            "kind": "constant",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "createProgram": {
          "jsdocs": {
            "description": "Creates a program from 2 script tags.",
            "params": [
              {
                "type": {
                  "names": [
                    "WebGLRenderingContext"
                  ]
                },
                "nullable": false,
                "description": "The WebGL Context.",
                "name": "gl"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "vertex shader as raw text",
                "name": "vertexSource"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "fragment shader as raw text",
                "name": "fragmentSource"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "WebGLProgram"
                  ]
                },
                "nullable": false,
                "description": "a WebGL program"
              }
            ],
            "name": "createProgram",
            "longname": "createProgram",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "deallocProgram": {
          "jsdocs": {
            "name": "deallocProgram",
            "longname": "deallocProgram",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "drawProgram": {
          "jsdocs": {
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a link to the WebGL instance",
                "name": "gl"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "1 or 2, which WebGL version.",
                "name": "version"
              },
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "the result of calling CreasePattern() FoldedForm()...",
                "name": "bundle"
              },
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "the result of calling makeUniforms()",
                "name": "uniforms"
              }
            ],
            "name": "drawProgram",
            "longname": "drawProgram",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "foldedForm": {
          "type": "Function"
        },
        "foldedFormEdges": {
          "type": "Function"
        },
        "foldedFormFaces": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "foldedFormFaces",
            "longname": "foldedFormFaces",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "foldedFormFacesOutlined": {
          "type": "Function"
        },
        "hexToRGB": {
          "jsdocs": {
            "description": "Convert a hex-style color string into 3 RGB values",
            "params": [
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "a hex color code as a string",
                "name": "value"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "number[]"
                  ]
                },
                "description": "three values between 0 and 1"
              }
            ],
            "name": "hexToRGB",
            "longname": "hexToRGB",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "initialize": {
          "jsdocs": {
            "description": "SVG (c) Kraft",
            "name": "initialize",
            "longname": "initialize",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeCPEdgesElementArrays": {
          "type": "Function"
        },
        "makeCPEdgesVertexArrays": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "makeCPEdgesVertexArrays",
            "longname": "makeCPEdgesVertexArrays",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeCPEdgesVertexData": {
          "type": "Function"
        },
        "makeCPFacesElementArrays": {
          "type": "Function"
        },
        "makeCPFacesVertexArrays": {
          "type": "Function"
        },
        "makeFacesVertexData": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "makeFacesVertexData",
            "longname": "makeFacesVertexData",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeFoldedElementArrays": {
          "jsdocs": {
            "description": "WebGL 2 can handle Uint32Array. WebGL 1 cannot and must use 16 bit.",
            "name": "makeFoldedElementArrays",
            "longname": "makeFoldedElementArrays",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeFoldedVertexArrays": {
          "jsdocs": {
            "description": "Rabbit Ear (c) Kraft",
            "name": "makeFoldedVertexArrays",
            "longname": "makeFoldedVertexArrays",
            "kind": "function",
            "scope": "global",
            "params": []
          },
          "type": "Function"
        },
        "makeModelMatrix": {
          "jsdocs": {
            "description": "build an aspect-fit model matrix\n(possibly an inverse-model matrix)\nwhich brings the vertices inside of a 2x2x2 origin-centered bounding box.",
            "params": [
              {
                "type": {
                  "names": [
                    "FOLD"
                  ]
                },
                "description": "a FOLD graph",
                "name": "graph"
              }
            ],
            "name": "makeModelMatrix",
            "longname": "makeModelMatrix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeProjectionMatrix": {
          "jsdocs": {
            "description": "Create a 4x4 projection matrix for either a\nperspective or orthographic view.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "an HTML canvas",
                "name": "canvas"
              },
              {
                "type": {
                  "names": [
                    "string"
                  ]
                },
                "description": "\"orthographic\" or \"perspective\"",
                "name": "perspective",
                "defaultvalue": "perspective"
              },
              {
                "type": {
                  "names": [
                    "number"
                  ]
                },
                "description": "the field of view (perspective only)",
                "name": "fov",
                "defaultvalue": 45
              }
            ],
            "name": "makeProjectionMatrix",
            "longname": "makeProjectionMatrix",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        },
        "makeThickEdgesElementArrays": {
          "type": "Function"
        },
        "makeThickEdgesVertexArrays": {
          "type": "Function"
        },
        "makeThickEdgesVertexData": {
          "type": "Function"
        },
        "rebuildViewport": {
          "jsdocs": {
            "description": "Initialize a viewport for a WebGL context\nbased on the dimensions of the canvas.",
            "params": [
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "a WebGL instance",
                "name": "gl"
              },
              {
                "type": {
                  "names": [
                    "object"
                  ]
                },
                "description": "an HTML canvas",
                "name": "canvas"
              }
            ],
            "name": "rebuildViewport",
            "longname": "rebuildViewport",
            "kind": "function",
            "scope": "global"
          },
          "type": "Function"
        }
      },
      "type": "undefined"
    }
  }
}